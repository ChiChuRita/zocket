---
title: Routers
description: Organizing your application logic
icon: lucide:folder-tree
---

Routers are the backbone of your Zocket application. They define the structure of your API and hold your procedures.

## Creating a Router

You create a router using the `zo.router()` method.

```typescript
const appRouter = zo.router()
  .outgoing({
    // Server -> Client messages
  })
  .incoming(({ send }) => ({
    // Client -> Server messages
  }));
```

## Modularizing Routers

For larger applications, keep your router definition modular by extracting â€œsectionsâ€ into helpers and composing them with object spread.

```typescript
// chat.module.ts
export const chatOutgoing = {
  chat: {
    message: z.object({ text: z.string(), from: z.string() }),
  },
} as const;

export function chatIncoming({ send }) {
  return {
    chat: {
      post: zo.message
        .input(z.object({ text: z.string() }))
        .handle(({ ctx, input }) => {
          send.chat
            .message({ text: input.text, from: ctx.clientId })
            .broadcast();
        }),
    },
  } as const;
}

// app.router.ts
export const appRouter = zo
  .router()
  .outgoing({
    ...chatOutgoing,
    // ...usersOutgoing,
  })
  .incoming(({ send }) => ({
    ...chatIncoming({ send }),
    // ...usersIncoming({ send }),
  }));
```

## Outgoing Messages

The `.outgoing()` method defines the contract for messages sent **from the Server to the Client**.

```typescript
.outgoing({
  chat: {
    message: z.object({
      id: z.string(),
      text: z.string(),
      timestamp: z.number()
    })
  }
})
```

This provides type safety when you call `send.chat.message(...)`.

## Incoming Messages

The `.incoming()` method defines the contract for messages sent **from the Client to the Server**. It takes a callback that provides the `send` object (mirrored from `.outgoing`) and expects you to return an object of procedures.

```typescript
.incoming(({ send }) => ({
  // Procedures defined here
}))
```
