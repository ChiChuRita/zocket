---
title: Routers
description: Organizing your application logic
icon: lucide:folder-tree
---

Routers are the backbone of your Zocket application. They define the structure of your API and hold your procedures.

## Creating a Router

You create a router using the `zo.router()` method.

```typescript
const appRouter = zo.router()
  .outgoing({
    // Server -> Client messages
  })
  .incoming(({ send }) => ({
    // Client -> Server messages
  }));
```

## Modularizing Routers

For larger applications, you can split your router into multiple sub-routers and merge them.

**Note:** Zocket currently supports a single root router definition in the `incoming` handler, but you can structure your object arbitrarily deep.

```typescript
// Define sub-sections in your main router structure
.incoming(({ send }) => ({
  auth: {
    login: zo.message.handle(/* ... */),
    logout: zo.message.handle(/* ... */),
  },
  chat: {
    send: zo.message.handle(/* ... */),
  },
  posts: {
    create: zo.message.handle(/* ... */),
    list: zo.message.handle(/* ... */),
  }
}))
```

## Outgoing Messages

The `.outgoing()` method defines the contract for messages sent **from the Server to the Client**.

```typescript
.outgoing({
  chat: {
    onMessage: z.object({
      id: z.string(),
      text: z.string(),
      timestamp: z.date()
    })
  }
})
```

This provides type safety when you call `send.chat.onMessage(...)`.

## Incoming Messages

The `.incoming()` method defines the contract for messages sent **from the Client to the Server**. It takes a callback that provides the `send` object (mirrored from `.outgoing`) and expects you to return an object of procedures.

```typescript
.incoming(({ send }) => ({
  // Procedures defined here
}))
```
