---
title: Middleware
description: Per-message context augmentation and gating
icon: lucide:layers
---

Zocket middleware runs **before** a handler and can:

- Add derived values to `ctx` (type-safe context augmentation)
- Block execution (by throwing)

Unlike Koa/Express middleware, Zocket middleware **does not** receive a `next()` function and does not wrap execution — it’s a simple “compute extra context” step.

## Signature

```ts
const withExtras = zo.message.use(({ ctx, payload }) => {
  // ctx: per-connection context (plus built-ins like clientId/rooms)
  // payload: validated input for this message (if you used .input(...))
  return {
    // anything you return is merged into ctx for the handler
  };
});
```

## Authentication + context narrowing

If your `onConnect` sets `user` as nullable, middleware can both enforce auth and **narrow** the type for handlers.

```ts
type User = { id: string; name: string };

// onConnect returns: { user: User | null }
const requireUser = zo.message.use(({ ctx }) => {
  if (!ctx.user) throw new Error("UNAUTHORIZED");
  return { user: ctx.user };
});

// Now ctx.user is non-null inside handlers that use requireUser
const protectedMessage = requireUser.input(/* ... */).handle(({ ctx }) => {
  ctx.user.id;
});
```

## Composing middleware

```ts
const requireAdmin = ({ ctx }: { ctx: { userRole: "admin" | "user" } }) => {
  if (ctx.userRole !== "admin") throw new Error("FORBIDDEN");
  return { isAdmin: true as const };
};

const adminMessage = requireUser.use(requireAdmin);
```

## Notes on errors (current behavior)

As of `@zocket/core@0.1.0`, thrown errors are not serialized back to the client. If middleware throws, a client call may eventually reject due to the RPC timeout. If you need reliable error responses, return a typed “result” object (e.g. `{ ok: false, error: ... }`) from your handler instead of throwing, or send an explicit outgoing error event.
