---
title: Middleware
description: Reusable logic for authentication and logging
icon: lucide:layers
---

Middleware allows you to run code before your procedure handler. It is useful for:
- Authentication & Authorization
- Logging
- Context modification/injection
- Rate limiting

## Defining Middleware

Use `zo.message.use()` to define middleware.

```typescript
const loggerMiddleware = zo.message.use(async ({ ctx, next }) => {
  const start = Date.now();
  
  // Run the next middleware/handler
  const result = await next();
  
  const duration = Date.now() - start;
  console.log(`Duration: ${duration}ms`);
  
  return result;
});
```

## Authentication Example

You can throw errors in middleware to abort the request.

```typescript
const authMiddleware = zo.message.use(({ ctx, next }) => {
  if (!ctx.user) {
    throw new Error("UNAUTHORIZED");
  }
  
  // You can modify the context for the next steps
  return next({
    ctx: {
      ...ctx,
      // Narrow the type of user to be NonNullable
      user: ctx.user,
    }
  });
});
```

## Using Middleware

You can chain middleware on your procedures.

```typescript
const protectedProcedure = zo.message.use(loggerMiddleware).use(authMiddleware);

.incoming(() => ({
  secretData: protectedProcedure
    .input(z.string())
    .handle(({ ctx }) => {
      // ctx.user is guaranteed to be defined here
      return db.getSecret(ctx.user.id);
    })
}))
```

## Context Injection

Middleware is a great place to inject database connections or services into the context if they aren't already there.

```typescript
const dbMiddleware = zo.message.use(({ ctx, next }) => {
  return next({
    ctx: {
      ...ctx,
      db: new DatabaseConnection(),
    }
  });
});
```
