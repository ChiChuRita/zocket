---
title: Hooks
description: useCall, useMutation, useEvent, and more
icon: lucide:anchor
---

When you initialize Zocket with `createZocketReact<AppRouter>()`, it returns a set of hooks that are fully typed for your specific router.

## useClient

Returns the typed `ZocketClient` instance from context.

```tsx
const client = zocket.useClient();
```

## useConnectionState

Tracks the current connection status of the WebSocket.

```tsx
const { status, lastError } = zocket.useConnectionState();
// status: "connecting" | "open" | "closed"
```

## useEvent

A specialized hook for subscribing to real-time events. It handles the subscription lifecycle (subscribe on mount, unsubscribe on unmount).

```tsx
function Chat() {
  const client = zocket.useClient();
  const [messages, setMessages] = useState([]);

  zocket.useEvent(client.on.chat.newMessage, (msg) => {
    setMessages(prev => [...prev, msg]);
  });

  return <ul>{messages.map(m => <li key={m.id}>{m.text}</li>)}</ul>;
}
```

## useCall (RPC Query)

Used for procedures that follow a Request-Response pattern. It provides automatic loading and error state management.

```tsx
function Profile({ userId }) {
  const { data, loading, error, refetch } = zocket.useCall(
    (c) => c.users.getProfile({ id: userId }),
    [userId], // Dependencies: refetches when userId changes
    { enabled: !!userId } // Optional: only run if userId exists
  );

  if (loading) return <Spinner />;
  if (error) return <Error message={error.message} />;
  
  return <h1>{data.name}</h1>;
}
```

## useMutation (RPC Mutation)

Used for imperative actions like sending data, where you want to track the status of the request.

```tsx
function NewMessage() {
  const sendMessage = zocket.useMutation(
    (client, text: string) => client.chat.send({ text })
  );

  return (
    <div>
      <button 
        disabled={sendMessage.loading}
        onClick={() => sendMessage.mutate("Hello world")}
      >
        {sendMessage.loading ? 'Sending...' : 'Send'}
      </button>
      {sendMessage.error && <p>Error: {sendMessage.error.message}</p>}
    </div>
  );
}
```

## Standalone Hooks

If you prefer not to use the factory pattern, you can import standalone versions of these hooks from `@zocket/react`. However, you will need to pass the `client` manually and provide generics for full type safety.

```tsx
import { useEvent, useCall } from "@zocket/react";

// Standalone usage (less common)
useEvent(client.on.chat.message, (data) => { ... });

const { data } = useCall(
  client,
  (c) => c.getUsers(),
  []
);
```
