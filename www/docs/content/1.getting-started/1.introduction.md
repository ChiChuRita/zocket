---
title: Introduction
description: Learn about Zocket and what makes it the ideal choice for building type-safe real-time applications.
---

# Introduction

Zocket is an end-to-end type-safe WebSocket library for TypeScript that brings the tRPC developer experience to real-time communication.

## What is Zocket?

Zocket allows you to build real-time applications with full type safety from server to client. It eliminates the manual work of serialization, deserialization, and message routing while providing excellent TypeScript inference and IDE support.

## Key Features

### End-to-End Type Safety

Define your message schemas once on the server, and get automatic type inference on the client. No code generation, no manual type definitions.

```typescript
// Server defines the schema
const router = {
  chat: {
    message: zo.message.incoming({
      payload: z.object({ text: z.string() }),
    }),
  },
};

// Client gets full type safety automatically
client.send.chat.message({ text: "Hello!" }); // ✅ Type-safe
client.send.chat.message({ count: 5 }); // ❌ Type error
```

### tRPC-like Developer Experience

If you've used tRPC, you'll feel right at home. Zocket provides the same intuitive API with autocomplete, inline documentation, and compile-time type checking.

### Built-in Features

- **Rooms & Broadcasting**: Subscribe clients to rooms and broadcast messages effortlessly
- **Middleware System**: Composable middleware for authentication, validation, and custom logic
- **Auto Reconnection**: Automatic reconnection with exponential backoff
- **React Hooks**: Type-safe React integration out of the box
- **Multiple Validators**: Support for Zod, Valibot, and any StandardSchema-compliant library

## Architecture Overview

Zocket follows a simple but powerful architecture:

1. **Router Definition**: Define your message types and their schemas
2. **Handler Implementation**: Implement handlers for incoming messages
3. **Type Sharing**: Share the router type with your client
4. **Type-safe Client**: Use the client with full type inference

```typescript
// 1. Define router on server
const router = {
  echo: {
    ping: zo.message.incoming({ payload: z.object({ msg: z.string() }) }),
    pong: zo.message.outgoing({ payload: z.object({ reply: z.string() }) }),
  },
};

// 2. Implement handlers
const appRouter = zo.router(router, {
  echo: {
    ping: ({ payload, ctx }) => {
      ctx.send.echo.pong({ reply: `Got: ${payload.msg}` }).to([ctx.clientId]);
    },
  },
});

// 3. Export type
export type AppRouter = typeof router;

// 4. Use on client with full types
const client = createZocketClient<AppRouter>("ws://localhost:3000");
```

## When to Use Zocket

Zocket is perfect for:

- Real-time chat applications
- Multiplayer games
- Live dashboards and monitoring
- Collaborative editing tools
- Live notifications systems
- Any application requiring bidirectional real-time communication

## Comparison with Alternatives

### vs Raw WebSockets

Raw WebSockets require manual message routing, serialization, and have no type safety. See the [Motivation](/getting-started/motivation) page for a detailed comparison.

### vs Socket.IO

Socket.IO is great but lacks end-to-end type safety. You need to manually keep server and client event types in sync.

### vs tRPC

tRPC is excellent for HTTP-based APIs but doesn't support WebSocket subscriptions in the same way. Zocket is specifically designed for bidirectional real-time communication.

## Browser and Runtime Support

Zocket works in:

- **Server**: Bun (native support), Node.js (via adapters)
- **Client**: All modern browsers, Node.js, React Native (with WebSocket polyfill)
- **TypeScript**: 5.0+

## Next Steps

- [Understand why Zocket exists](/getting-started/motivation)
- [Install Zocket](/getting-started/installation)
- [Build your first app](/getting-started/quick-start)
