---
title: Motivation
description: Understand the problems Zocket solves and why you should use it for your real-time applications.
---

# Why Zocket?

Building real-time applications with WebSockets in TypeScript is powerful, but it comes with significant challenges. Let's explore the problems Zocket solves.

## The Problem with Raw WebSockets

### 1. No Type Safety

With raw WebSockets, you're working with strings. There's no way to ensure the data you're sending matches what the receiver expects.

### 2. Manual Message Routing

You need to implement your own message routing system, parsing message types, and dispatching to appropriate handlers.

### 3. Boilerplate Code

Serialization, deserialization, error handling, connection management - all require substantial boilerplate.

### 4. Easy to Make Mistakes

Typos in event names, incorrect payload shapes, missing error handling - these bugs only appear at runtime.

## Comparison: Raw Bun vs Zocket

Let's build the same chat feature with both approaches to see the difference.

### With Raw Bun WebSockets

```typescript
// ❌ Server - Manual routing, no type safety
import type { ServerWebSocket } from "bun";

type WebSocketData = {
  clientId: string;
  username: string;
};

const clients = new Map<string, ServerWebSocket<WebSocketData>>();

Bun.serve({
  port: 3000,
  fetch(req, server) {
    const url = new URL(req.url);
    const username = url.searchParams.get("username") || "Anonymous";

    const upgraded = server.upgrade(req, {
      data: {
        clientId: crypto.randomUUID(),
        username,
      },
    });

    if (!upgraded) {
      return new Response("Upgrade failed", { status: 500 });
    }
  },
  websocket: {
    open(ws) {
      clients.set(ws.data.clientId, ws);
      console.log(`${ws.data.username} connected`);
    },

    message(ws, message) {
      try {
        const data = JSON.parse(message as string);

        // Manual routing - easy to make mistakes
        if (data.type === "chat.message") {
          // Manual validation - no type safety
          if (!data.payload || typeof data.payload.text !== "string") {
            console.error("Invalid payload");
            return;
          }

          // Manual serialization
          const response = JSON.stringify({
            type: "chat.onMessage",
            payload: {
              user: ws.data.username,
              text: data.payload.text,
              timestamp: new Date().toISOString(),
            },
          });

          // Manual broadcasting
          clients.forEach((client) => {
            client.send(response);
          });
        } else if (data.type === "chat.typing") {
          // Repeat validation and routing for each message type...
          if (!data.payload || typeof data.payload.isTyping !== "boolean") {
            console.error("Invalid payload");
            return;
          }

          const response = JSON.stringify({
            type: "chat.onTyping",
            payload: {
              user: ws.data.username,
              isTyping: data.payload.isTyping,
            },
          });

          clients.forEach((client) => {
            if (client.data.clientId !== ws.data.clientId) {
              client.send(response);
            }
          });
        }
        // Add more message types... lots of boilerplate!
      } catch (error) {
        console.error("Failed to parse message:", error);
      }
    },

    close(ws) {
      clients.delete(ws.data.clientId);
      console.log(`${ws.data.username} disconnected`);
    },
  },
});
```

```typescript
// ❌ Client - No type safety, manual event handling
const ws = new WebSocket("ws://localhost:3000?username=Alice");

ws.onopen = () => {
  console.log("Connected");
};

ws.onmessage = (event) => {
  try {
    const data = JSON.parse(event.data);

    // Manual routing - typos won't be caught
    if (data.type === "chat.onMessage") {
      // No type checking - could be wrong shape
      console.log(`${data.payload.user}: ${data.payload.text}`);
    } else if (data.type === "chat.onTyping") {
      console.log(`${data.payload.user} is typing...`);
    }
  } catch (error) {
    console.error("Failed to parse message:", error);
  }
};

// Manual serialization - no type safety
const sendMessage = (text: string) => {
  ws.send(
    JSON.stringify({
      type: "chat.message", // Could typo this!
      payload: { text }, // Could send wrong shape!
    })
  );
};

const sendTyping = (isTyping: boolean) => {
  ws.send(
    JSON.stringify({
      type: "chat.typing",
      payload: { isTyping },
    })
  );
};

sendMessage("Hello!");
```

**Problems with this approach:**

1. No compile-time type checking
2. Manual message routing on both sides
3. Easy to typo event names
4. No validation until runtime
5. Lots of boilerplate
6. Error-prone serialization/deserialization
7. No IDE autocomplete
8. Hard to maintain as app grows

### With Zocket

```typescript
// ✅ Server - Type-safe, declarative, clean
import { z } from "zod";
import { zocket, createBunServer } from "@zocket/core";

const zo = zocket.create({
  headers: z.object({
    username: z.string().default("Anonymous"),
  }),
  onConnect: (headers, clientId) => {
    console.log(`${headers.username} connected`);
    return { username: headers.username };
  },
  onDisconnect: (ctx) => {
    console.log(`${ctx.username} disconnected`);
  },
});

const router = {
  chat: {
    message: zo.message.incoming({
      payload: z.object({ text: z.string() }),
    }),
    typing: zo.message.incoming({
      payload: z.object({ isTyping: z.boolean() }),
    }),
    onMessage: zo.message.outgoing({
      payload: z.object({
        user: z.string(),
        text: z.string(),
        timestamp: z.date(),
      }),
    }),
    onTyping: zo.message.outgoing({
      payload: z.object({
        user: z.string(),
        isTyping: z.boolean(),
      }),
    }),
  },
};

export type ChatRouter = typeof router;

const appRouter = zo.router(router, {
  chat: {
    message: ({ payload, ctx }) => {
      ctx.send.chat
        .onMessage({
          user: ctx.username,
          text: payload.text,
          timestamp: new Date(),
        })
        .broadcast();
    },
    typing: ({ payload, ctx }) => {
      ctx.send.chat
        .onTyping({
          user: ctx.username,
          isTyping: payload.isTyping,
        })
        .broadcast();
    },
  },
});

const handlers = createBunServer(appRouter, zo);
Bun.serve({
  fetch: handlers.fetch,
  websocket: handlers.websocket,
  port: 3000,
});
```

```typescript
// ✅ Client - Fully type-safe with autocomplete
import { createZocketClient } from "@zocket/core";
import type { ChatRouter } from "./server";

const client = createZocketClient<ChatRouter>("ws://localhost:3000", {
  headers: { username: "Alice" },
});

// Type-safe event listeners with full autocomplete
client.on.chat.onMessage((data) => {
  // data is fully typed: { user: string; text: string; timestamp: Date }
  console.log(`${data.user}: ${data.text}`);
});

client.on.chat.onTyping((data) => {
  // data is fully typed: { user: string; isTyping: boolean }
  console.log(`${data.user} is typing...`);
});

// Type-safe sending with autocomplete and compile-time checks
client.send.chat.message({ text: "Hello!" }); // ✅ Type-safe
client.send.chat.typing({ isTyping: true }); // ✅ Type-safe

// These would be caught at compile time:
// client.send.chat.message({ count: 5 }); // ❌ Type error
// client.send.chat.typo({ text: 'Hi' }); // ❌ Type error
```

**Benefits of Zocket:**

1. ✅ Full end-to-end type safety
2. ✅ IDE autocomplete everywhere
3. ✅ Compile-time error checking
4. ✅ Automatic message routing
5. ✅ Built-in validation with Zod/Valibot
6. ✅ Clean, declarative API
7. ✅ Much less code
8. ✅ Scales easily

## Key Improvements

### Type Safety

With raw WebSockets, you're dealing with `any` types and runtime validation. With Zocket, TypeScript catches errors before you even run your code.

### Developer Experience

Zocket provides autocomplete, inline documentation, and immediate feedback in your IDE. You'll spend less time debugging and more time building features.

### Reduced Boilerplate

Zocket handles serialization, deserialization, message routing, and validation automatically. You write business logic, not infrastructure code.

### Maintainability

As your application grows, Zocket's type system ensures refactoring is safe. Change a message schema, and TypeScript will show you everywhere that needs updating.

### Built-in Best Practices

Zocket includes automatic reconnection, room management, middleware support, and more - features you'd have to build yourself with raw WebSockets.

## Real-World Impact

Here's what developers report after switching to Zocket:

- **50-70% less code** for WebSocket functionality
- **Zero runtime type errors** after proper setup
- **Faster development** with autocomplete and type checking
- **Easier onboarding** for new team members
- **Safer refactoring** with compiler assistance

## When You Might Not Need Zocket

Zocket is designed for TypeScript applications that need type safety. If you're:

- Building a simple prototype
- Working in plain JavaScript
- Need extremely low-level WebSocket control
- Have very specific binary protocol requirements

Then raw WebSockets might be sufficient. But for most TypeScript applications, Zocket will save you time and prevent bugs.

## Next Steps

Ready to experience the difference?

- [Install Zocket](/getting-started/installation)
- [Build your first app](/getting-started/quick-start)
- [Explore examples](/examples/ping-pong)
