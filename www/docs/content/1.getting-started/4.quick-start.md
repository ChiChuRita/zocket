---
title: Quick Start
description: Build your first type-safe real-time application with Zocket in minutes.
---

# Quick Start

Let's build a simple ping-pong application to understand the basics of Zocket. You'll create a server that responds to ping messages with pong messages.

## Step 1: Create the Server

Create a file called `server.ts`:

```typescript
import { z } from "zod";
import { zocket, createBunServer } from "@zocket/core";

// 1. Create a Zocket instance
const zo = zocket.create({
  headers: z.object({
    user: z.string().default("guest"),
  }),
  onConnect: (headers, clientId) => {
    console.log(`âœ… ${headers.user} connected (${clientId})`);
    return {
      user: headers.user,
    };
  },
  onDisconnect: (ctx, clientId) => {
    console.log(`âŒ ${ctx.user} disconnected (${clientId})`);
  },
});

// 2. Define your router
const router = {
  echo: {
    ping: zo.message.incoming({
      payload: z.object({ message: z.string() }),
    }),
    pong: zo.message.outgoing({
      payload: z.object({ reply: z.string() }),
    }),
  },
};

// 3. Export the router type for the client
export type AppRouter = typeof router;

// 4. Implement handlers
const appRouter = zo.router(router, {
  echo: {
    ping: ({ payload, ctx }) => {
      const reply = `pong: ${payload.message}`;
      ctx.send.echo.pong({ reply }).to([ctx.clientId]);
    },
  },
});

// 5. Start the server
const handlers = createBunServer(appRouter, zo);

Bun.serve({
  fetch: handlers.fetch,
  websocket: handlers.websocket,
  port: 3000,
  hostname: "127.0.0.1",
});

console.log("ðŸš€ Server running on ws://localhost:3000");
```

### Understanding the Code

1. **Create Instance**: `zocket.create()` sets up your WebSocket server with header validation and lifecycle hooks
2. **Define Router**: The router defines the shape of messages (incoming and outgoing)
3. **Export Type**: Export the router type to share with your client
4. **Implement Handlers**: Define what happens when messages are received
5. **Start Server**: Use `createBunServer` to create Bun-compatible handlers

## Step 2: Create the Client

Create a file called `client.ts`:

```typescript
import { createZocketClient } from "@zocket/core";
import type { AppRouter } from "./server";

// 1. Create a type-safe client
const client = createZocketClient<AppRouter>("ws://localhost:3000", {
  headers: { user: "Alice" },
  debug: true,
});

// 2. Listen for messages
client.on.echo.pong((data) => {
  console.log("Received:", data.reply);
});

// 3. Wait for connection
client.onOpen(() => {
  console.log("Connected!");

  // 4. Send a message
  client.send.echo.ping({ message: "Hello!" });
});

// 5. Handle disconnection
client.onClose(() => {
  console.log("Disconnected");
});
```

### Understanding the Client Code

1. **Create Client**: Pass the router type to get full type safety
2. **Listen for Messages**: Subscribe to outgoing messages from the server
3. **Connection Events**: Handle connection lifecycle
4. **Send Messages**: Send type-safe messages to the server

## Step 3: Run Your Application

Start the server:

```bash
bun server.ts
```

In another terminal, run the client:

```bash
bun client.ts
```

You should see:

```
# Server terminal
âœ… Alice connected (client_1234...)
âŒ Alice disconnected (client_1234...)

# Client terminal
Connected!
Received: pong: Hello!
Disconnected
```

## What Just Happened?

1. The client connected to the server with headers
2. The server validated headers and created user context
3. The client sent a ping message
4. The server received it, processed it, and sent back a pong
5. The client received the pong and logged it
6. Everything was type-safe with full autocomplete

## Adding More Features

Let's enhance our example with broadcasting:

```typescript
// server.ts
const router = {
  echo: {
    ping: zo.message.incoming({
      payload: z.object({ message: z.string() }),
    }),
    pong: zo.message.outgoing({
      payload: z.object({ reply: z.string(), from: z.string() }),
    }),
  },
};

const appRouter = zo.router(router, {
  echo: {
    ping: ({ payload, ctx }) => {
      // Send to everyone!
      ctx.send.echo
        .pong({
          reply: payload.message,
          from: ctx.user,
        })
        .broadcast();
    },
  },
});
```

Now every client receives pong messages from all other clients.

## Type Safety in Action

Try making an intentional mistake:

```typescript
// This will fail TypeScript compilation
client.send.echo.ping({ wrongField: "Hello!" });
// Error: Object literal may only specify known properties

client.send.echo.typo({ message: "Hi" });
// Error: Property 'typo' does not exist
```

Your IDE will show these errors immediately, preventing runtime bugs.

## Project Structure

For a real application, organize your code like this:

```
my-app/
â”œâ”€â”€ server/
â”‚   â”œâ”€â”€ index.ts         # Server entry
â”‚   â””â”€â”€ router.ts        # Router definitions
â”œâ”€â”€ client/
â”‚   â””â”€â”€ index.ts         # Client code
â””â”€â”€ shared/
    â””â”€â”€ types.ts         # export type AppRouter
```

**shared/types.ts:**

```typescript
import type { router } from "../server/router";
export type AppRouter = typeof router;
```

**server/router.ts:**

```typescript
import { z } from "zod";
import { zocket } from "@zocket/core";

const zo = zocket.create({
  headers: z.object({ user: z.string() }),
  onConnect: (headers) => ({ user: headers.user }),
});

export const router = {
  // Your routes
};

export const appRouter = zo.router(router, {
  // Your handlers
});
```

**server/index.ts:**

```typescript
import { createBunServer } from "@zocket/core";
import { appRouter, zo } from "./router";

const handlers = createBunServer(appRouter, zo);
Bun.serve({ fetch: handlers.fetch, websocket: handlers.websocket, port: 3000 });
```

**client/index.ts:**

```typescript
import { createZocketClient } from "@zocket/core";
import type { AppRouter } from "../shared/types";

const client = createZocketClient<AppRouter>("ws://localhost:3000");
```

## Common Patterns

### Error Handling

```typescript
client.onOpen(() => {
  console.log("Connected");
});

client.onClose(() => {
  console.log("Disconnected - will auto-reconnect");
});
```

Zocket handles reconnection automatically with exponential backoff.

### Multiple Event Listeners

```typescript
client.on.echo.pong((data) => {
  console.log("Handler 1:", data.reply);
});

client.on.echo.pong((data) => {
  console.log("Handler 2:", data.reply);
});
```

Both handlers will be called.

### Unsubscribing

```typescript
const unsubscribe = client.on.echo.pong((data) => {
  console.log(data.reply);
});

// Later...
unsubscribe();
```

## Next Steps

Now that you have a basic app running:

- [Learn about routers](/core-concepts/routers) for more complex message hierarchies
- [Understand context](/core-concepts/context) for user data and rooms
- [Add middleware](/core-concepts/middleware) for authentication
- [Explore examples](/examples/ping-pong) for real-world patterns
- [Use with React](/react/overview) for frontend applications
