---
title: Overview
description: Understand the core concepts and architecture of Zocket.
---

# Core Concepts Overview

Zocket's architecture is built around a few key concepts that work together to provide end-to-end type safety for WebSocket communication.

## Architecture Diagram

```
┌─────────────────┐                    ┌─────────────────┐
│     Client      │◄──────────────────►│     Server      │
│                 │    WebSocket       │                 │
│  - send         │                    │  - Router       │
│  - on           │                    │  - Handlers     │
│  - typed        │                    │  - Context      │
└─────────────────┘                    └─────────────────┘
        │                                      │
        │                                      │
        └──────────► Router Type ◄─────────────┘
                    (Shared Types)
```

## Key Concepts

### 1. Routers

Routers define the structure of your WebSocket API. They contain message definitions organized hierarchically.

```typescript
const router = {
  chat: {
    message: zo.message.incoming({ payload: z.object({ text: z.string() }) }),
    onMessage: zo.message.outgoing({ payload: z.object({ text: z.string() }) }),
  },
  users: {
    join: zo.message.incoming({ payload: z.object({ name: z.string() }) }),
    onJoin: zo.message.outgoing({ payload: z.object({ name: z.string() }) }),
  },
};
```

Routes can be nested arbitrarily deep, providing excellent organization for complex applications.

[Learn more about routers →](/core-concepts/routers)

### 2. Messages

Messages come in two directions:

- **Incoming**: Messages sent from client to server
- **Outgoing**: Messages sent from server to client

Each message has a payload schema that's validated automatically.

```typescript
// Incoming (client → server)
ping: zo.message.incoming({
  payload: z.object({ message: z.string() }),
});

// Outgoing (server → client)
pong: zo.message.outgoing({
  payload: z.object({ reply: z.string() }),
});
```

[Learn more about messages →](/core-concepts/messages)

### 3. Handlers

Handlers are functions that process incoming messages. They receive the validated payload and context.

```typescript
const appRouter = zo.router(router, {
  chat: {
    message: ({ payload, ctx }) => {
      // payload is fully typed!
      console.log(payload.text);

      // ctx contains user data, send functions, etc.
      ctx.send.chat.onMessage({ text: payload.text }).broadcast();
    },
  },
});
```

[Learn more about handlers →](/core-concepts/handlers)

### 4. Context

Context is an object available in every handler containing:

- User data from `onConnect`
- `send` methods for sending messages
- `rooms` for room management
- `clientId` for identifying the client

```typescript
({ payload, ctx }) => {
  console.log(ctx.user);       // User data
  console.log(ctx.clientId);   // Unique client ID
  ctx.rooms.join('room1');     // Join a room
  ctx.send.chat.message({...}).to([ctx.clientId]); // Send message
}
```

[Learn more about context →](/core-concepts/context)

### 5. Middleware

Middleware functions run before handlers and can add data to the context or perform validation.

```typescript
const authenticated = zo.message.use(({ ctx }) => {
  if (!ctx.isAuthenticated) {
    throw new Error("Unauthorized");
  }
  return { verified: true };
});

const router = {
  admin: {
    action: authenticated.incoming({
      payload: z.object({ command: z.string() }),
    }),
  },
};
```

[Learn more about middleware →](/core-concepts/middleware)

### 6. Rooms

Rooms allow you to group clients and broadcast messages to specific groups.

```typescript
// In handler
ctx.rooms.join('lobby');                    // Join a room
ctx.rooms.leave('lobby');                   // Leave a room
ctx.send.chat.message({...}).toRoom(['lobby']); // Send to room
```

[Learn more about rooms →](/core-concepts/rooms)

## Data Flow

### Client to Server

1. Client calls `client.send.route.name(payload)`
2. Payload is serialized to JSON
3. Message is sent over WebSocket
4. Server receives and parses message
5. Server validates payload against schema
6. Server runs middleware (if any)
7. Handler is called with typed payload and context
8. Handler processes message

### Server to Client

1. Handler calls `ctx.send.route.name(payload)`
2. Returns a fluent API (`.to()`, `.toRoom()`, `.broadcast()`)
3. Payload is validated against schema
4. Message is serialized to JSON
5. Sent to target clients over WebSocket
6. Clients receive and parse message
7. Registered listeners are called with typed payload

## Type Safety Flow

```typescript
// Server defines schema
const router = {
  chat: {
    message: zo.message.incoming({
      payload: z.object({ text: z.string(), priority: z.number() }),
    }),
  },
};

// Type is extracted
export type AppRouter = typeof router;

// Client gets full type inference
const client = createZocketClient<AppRouter>("ws://...");

// TypeScript knows the exact shape
client.send.chat.message({
  text: "Hello", // ✅ string
  priority: 1, // ✅ number
});

client.send.chat.message({
  text: "Hello", // ✅
  priority: "high", // ❌ Type error: should be number
});
```

## Validation

Zocket validates all payloads automatically:

```typescript
// If client sends invalid data
client.send.chat.message({ text: 123 }); // Compiles, but...

// Server validates and rejects
// Console: "Invalid payload for message 'chat.message'"
// Handler is NOT called
```

This prevents invalid data from reaching your handlers.

## Connection Lifecycle

```typescript
const zo = zocket.create({
  headers: z.object({ token: z.string() }),

  // Called when client connects
  onConnect: async (headers, clientId) => {
    const user = await validateToken(headers.token);
    return { user }; // Becomes part of ctx
  },

  // Called when client disconnects
  onDisconnect: async (ctx, clientId) => {
    await logDisconnect(ctx.user);
  },
});
```

## Error Handling

Zocket handles errors gracefully:

- **Validation Errors**: Logged, message rejected
- **Middleware Errors**: Logged, handler not called
- **Handler Errors**: Logged, doesn't crash server
- **Connection Errors**: Automatic reconnection on client

## Performance Considerations

- **Validation**: Happens once per message, minimal overhead
- **Serialization**: Standard JSON, very fast
- **Routing**: Uses efficient Map lookups
- **Broadcasting**: Direct WebSocket sends, no extra copies

## Best Practices

1. **Organize Routes Hierarchically**: Group related messages together
2. **Keep Handlers Small**: Extract complex logic to separate functions
3. **Use Middleware for Crosscutting Concerns**: Auth, logging, metrics
4. **Validate Early**: Use strict schemas to catch errors fast
5. **Type Safety**: Never use `any`, leverage TypeScript fully

## Common Patterns

### Request-Response

```typescript
// Client sends
client.send.user.getProfile({ userId: "123" });

// Client listens for response
client.on.user.onProfile((data) => {
  console.log(data);
});

// Server sends back
ctx.send.user.onProfile({ ...profile }).to([ctx.clientId]);
```

### Broadcasting

```typescript
// Server sends to all
ctx.send.notification.alert({ message: "Hello!" }).broadcast();

// Or to specific clients
ctx.send.notification.alert({ message: "Hi!" }).to(["client1", "client2"]);
```

### Room-Based

```typescript
// Client joins room
client.send.chat.joinRoom({ roomId: "general" });

// Server adds to room
ctx.rooms.join("general");

// Server broadcasts to room
ctx.send.chat.message({ text: "Welcome!" }).toRoom(["general"]);
```

## Next Steps

Dive deeper into each concept:

- [Routers](/core-concepts/routers) - Define your API structure
- [Messages](/core-concepts/messages) - Incoming and outgoing messages
- [Handlers](/core-concepts/handlers) - Process incoming messages
- [Context](/core-concepts/context) - Access user data and utilities
- [Middleware](/core-concepts/middleware) - Add reusable logic
- [Rooms](/core-concepts/rooms) - Group and broadcast to clients
