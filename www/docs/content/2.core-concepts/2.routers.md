---
title: Routers
description: Learn how to define and organize your WebSocket API with routers.
---

# Routers

Routers are the foundation of your Zocket API. They define the structure of messages and provide the type information that flows through your entire application.

## Basic Router

A router is a plain JavaScript object with message definitions:

```typescript
import { z } from "zod";
import { zocket } from "@zocket/core";

const zo = zocket.create({
  headers: z.object({}),
});

const router = {
  ping: zo.message.incoming({
    payload: z.object({ message: z.string() }),
  }),
  pong: zo.message.outgoing({
    payload: z.object({ reply: z.string() }),
  }),
};
```

## Nested Routers

Organize related messages into nested structures:

```typescript
const router = {
  chat: {
    message: zo.message.incoming({
      payload: z.object({ text: z.string() }),
    }),
    typing: zo.message.incoming({
      payload: z.object({ isTyping: z.boolean() }),
    }),
    onMessage: zo.message.outgoing({
      payload: z.object({ user: z.string(), text: z.string() }),
    }),
  },
  users: {
    join: zo.message.incoming({
      payload: z.object({ name: z.string() }),
    }),
    leave: zo.message.incoming({
      payload: z.object({}) }),
    }),
    onJoin: zo.message.outgoing({
      payload: z.object({ name: z.string() }),
    }),
  },
};
```

Nesting can be arbitrary deep:

```typescript
const router = {
  api: {
    v1: {
      users: {
        profile: {
          get: zo.message.incoming({...}),
          update: zo.message.incoming({...}),
          onUpdate: zo.message.outgoing({...}),
        },
      },
    },
  },
};
```

## Message Types

Routers contain two types of messages:

### Incoming Messages

Messages sent from client to server:

```typescript
ping: zo.message.incoming({
  payload: z.object({ message: z.string() }),
});
```

These require a handler implementation.

### Outgoing Messages

Messages sent from server to client:

```typescript
pong: zo.message.outgoing({
  payload: z.object({ reply: z.string() }),
});
```

These don't need handlers (server initiates them).

## Router Registration

After defining your router, register it with handlers:

```typescript
const appRouter = zo.router(router, {
  chat: {
    message: ({ payload, ctx }) => {
      // Handle incoming message
    },
  },
  users: {
    join: ({ payload, ctx }) => {
      // Handle user join
    },
  },
});
```

The handler structure must match the router structure.

## Type Export

Export your router type for client use:

```typescript
const router = {
  // ... your routes
};

export type AppRouter = typeof router;
```

Clients import this type:

```typescript
import type { AppRouter } from "./server";

const client = createZocketClient<AppRouter>("ws://localhost:3000");
```

## Naming Conventions

Follow these conventions for clarity:

### Incoming Messages (client → server)

Use verb or action names:

- `send`, `create`, `update`, `delete`
- `join`, `leave`
- `ping`, `subscribe`

```typescript
{
  message: zo.message.incoming({...}),  // ✅ Clear action
  typing: zo.message.incoming({...}),   // ✅ Clear action
}
```

### Outgoing Messages (server → client)

Prefix with `on` to indicate they're events:

- `onMessage`, `onCreate`, `onUpdate`
- `onJoin`, `onLeave`
- `onPong`, `onSubscribed`

```typescript
{
  onMessage: zo.message.outgoing({...}),  // ✅ Clear event
  onTyping: zo.message.outgoing({...}),   // ✅ Clear event
}
```

This makes it clear which direction each message flows.

## Organizing Large Routers

For large applications, split routers into modules:

```typescript
// routes/chat.ts
export const chatRouter = {
  message: zo.message.incoming({...}),
  typing: zo.message.incoming({...}),
  onMessage: zo.message.outgoing({...}),
};

// routes/users.ts
export const usersRouter = {
  join: zo.message.incoming({...}),
  leave: zo.message.incoming({...}),
  onJoin: zo.message.outgoing({...}),
};

// router.ts
import { chatRouter } from './routes/chat';
import { usersRouter } from './routes/users';

export const router = {
  chat: chatRouter,
  users: usersRouter,
};
```

Similarly, split handlers:

```typescript
// handlers/chat.ts
export const chatHandlers = {
  message: ({ payload, ctx }) => {...},
  typing: ({ payload, ctx }) => {...},
};

// handlers/users.ts
export const usersHandlers = {
  join: ({ payload, ctx }) => {...},
  leave: ({ payload, ctx }) => {...},
};

// index.ts
const appRouter = zo.router(router, {
  chat: chatHandlers,
  users: usersHandlers,
});
```

## Route Paths

Routes are flattened to dot-notation internally:

```typescript
const router = {
  chat: {
    message: zo.message.incoming({...}),
  },
};

// Internally becomes: "chat.message"
```

On the client, you use the nested structure:

```typescript
client.send.chat.message({ text: 'Hi' });
client.on.chat.onMessage((data) => {...});
```

## Dynamic Routes

Routers are static by design (no dynamic routes). Use payload fields for dynamic data:

```typescript
// ❌ Don't do this (can't be typed)
const router = {
  [`room_${roomId}`]: {...}
};

// ✅ Do this instead
const router = {
  room: {
    join: zo.message.incoming({
      payload: z.object({ roomId: z.string() })
    })
  }
};
```

## Versioning

Include API versions in your router structure:

```typescript
const router = {
  v1: {
    chat: {...},
    users: {...},
  },
  v2: {
    chat: {...},  // Updated version
    users: {...},
  },
};
```

Clients specify which version to use:

```typescript
client.send.v1.chat.message({...});
client.send.v2.chat.message({...});
```

## Best Practices

### 1. Group Related Messages

```typescript
// ✅ Good: Related messages grouped
{
  chat: {
    message: zo.message.incoming({...}),
    onMessage: zo.message.outgoing({...}),
    typing: zo.message.incoming({...}),
    onTyping: zo.message.outgoing({...}),
  }
}

// ❌ Bad: Unorganized
{
  sendChatMessage: zo.message.incoming({...}),
  receiveChatMessage: zo.message.outgoing({...}),
  userTyping: zo.message.incoming({...}),
  typingNotification: zo.message.outgoing({...}),
}
```

### 2. Keep Routes Flat Where Possible

```typescript
// ✅ Good: Not over-nested
{
  users: {
    create: zo.message.incoming({...}),
    update: zo.message.incoming({...}),
  }
}

// ❌ Bad: Over-nested for no reason
{
  api: {
    resources: {
      users: {
        actions: {
          create: zo.message.incoming({...}),
        }
      }
    }
  }
}
```

### 3. Be Consistent

Use consistent naming patterns throughout:

```typescript
// ✅ Good: Consistent naming
{
  chat: {
    sendMessage: zo.message.incoming({...}),
    onMessage: zo.message.outgoing({...}),
  },
  users: {
    sendJoin: zo.message.incoming({...}),
    onJoin: zo.message.outgoing({...}),
  }
}
```

### 4. Document Complex Routes

Use TypeScript comments to document:

```typescript
const router = {
  game: {
    // Player sends move command
    move: zo.message.incoming({
      payload: z.object({
        direction: z.enum(['up', 'down', 'left', 'right']),
      }),
    }),

    // Server broadcasts game state every frame
    onState: zo.message.outgoing({
      payload: z.object({
        players: z.array(z.object({...})),
        timestamp: z.number(),
      }),
    }),
  },
};
```

## TypeScript Tips

### Extracting Route Types

```typescript
// Get incoming message type
type ChatMessage = typeof router.chat.message;

// Get payload type
type ChatMessagePayload = z.infer<typeof router.chat.message.payload>;
```

### Router Utility Types

```typescript
// Get all incoming route keys
type IncomingRoutes<T> = {
  [K in keyof T]: T[K] extends { _direction: "in" } ? K : never;
}[keyof T];

// Usage
type ChatIncoming = IncomingRoutes<typeof router.chat>;
// Result: 'message' | 'typing'
```

## Next Steps

- [Learn about messages](/core-concepts/messages)
- [Implement handlers](/core-concepts/handlers)
- [See router examples](/examples/ping-pong)
