---
title: Messages
description: Understanding incoming and outgoing messages in Zocket.
---

# Messages

Messages are the core building blocks of Zocket communication. They define what data can be sent between client and server with full type safety.

## Message Directions

### Incoming Messages (Client → Server)

Incoming messages are sent from the client to the server and require handler implementation:

```typescript
const router = {
  chat: {
    message: zo.message.incoming({
      payload: z.object({
        text: z.string(),
        timestamp: z.number(),
      }),
    }),
  },
};
```

**Client sends:**

```typescript
client.send.chat.message({
  text: "Hello!",
  timestamp: Date.now(),
});
```

**Server receives and handles:**

```typescript
const appRouter = zo.router(router, {
  chat: {
    message: ({ payload, ctx }) => {
      console.log(payload.text); // "Hello!"
    },
  },
});
```

### Outgoing Messages (Server → Client)

Outgoing messages are sent from the server to clients and don't require handlers:

```typescript
const router = {
  chat: {
    onMessage: zo.message.outgoing({
      payload: z.object({
        user: z.string(),
        text: z.string(),
      }),
    }),
  },
};
```

**Server sends:**

```typescript
ctx.send.chat
  .onMessage({
    user: "Alice",
    text: "Hello!",
  })
  .broadcast();
```

**Client receives:**

```typescript
client.on.chat.onMessage((data) => {
  console.log(`${data.user}: ${data.text}`);
});
```

## Payload Schemas

Every message has a payload schema defined with Zod or Valibot:

### With Zod

```typescript
import { z } from "zod";

const router = {
  user: {
    create: zo.message.incoming({
      payload: z.object({
        name: z.string().min(1).max(100),
        email: z.string().email(),
        age: z.number().int().positive().optional(),
        role: z.enum(["user", "admin", "moderator"]),
      }),
    }),
  },
};
```

### With Valibot

```typescript
import * as v from "valibot";

const router = {
  user: {
    create: zo.message.incoming({
      payload: v.object({
        name: v.pipe(v.string(), v.minLength(1), v.maxLength(100)),
        email: v.pipe(v.string(), v.email()),
        age: v.optional(v.pipe(v.number(), v.integer(), v.minValue(1))),
        role: v.picklist(["user", "admin", "moderator"]),
      }),
    }),
  },
};
```

Both provide automatic validation and type inference!

## Complex Payloads

### Nested Objects

```typescript
zo.message.incoming({
  payload: z.object({
    user: z.object({
      id: z.string(),
      profile: z.object({
        name: z.string(),
        avatar: z.string().url(),
      }),
    }),
    settings: z.object({
      theme: z.enum(["light", "dark"]),
      notifications: z.boolean(),
    }),
  }),
});
```

### Arrays

```typescript
zo.message.incoming({
  payload: z.object({
    users: z.array(
      z.object({
        id: z.string(),
        name: z.string(),
      })
    ),
    tags: z.array(z.string()),
  }),
});
```

### Unions

```typescript
zo.message.incoming({
  payload: z.object({
    content: z.union([
      z.object({ type: z.literal("text"), text: z.string() }),
      z.object({ type: z.literal("image"), url: z.string() }),
      z.object({
        type: z.literal("video"),
        url: z.string(),
        duration: z.number(),
      }),
    ]),
  }),
});
```

### Optional Fields

```typescript
zo.message.incoming({
  payload: z.object({
    text: z.string(),
    priority: z.number().optional(),
    metadata: z.record(z.string(), z.any()).optional(),
  }),
});
```

### Default Values

```typescript
zo.message.incoming({
  payload: z.object({
    text: z.string(),
    priority: z.number().default(0),
    timestamp: z.number().default(() => Date.now()),
  }),
});
```

## Empty Payloads

For messages without data, use an empty object:

```typescript
const router = {
  connection: {
    ping: zo.message.incoming({
      payload: z.object({}),
    }),
    pong: zo.message.outgoing({
      payload: z.object({}),
    }),
  },
};
```

**Client sends:**

```typescript
client.send.connection.ping({});
```

## Message Validation

Zocket automatically validates all payloads:

```typescript
const router = {
  chat: {
    message: zo.message.incoming({
      payload: z.object({
        text: z.string().min(1).max(500),
      }),
    }),
  },
};
```

**Valid message:**

```typescript
client.send.chat.message({ text: "Hello!" }); // ✅ Passes validation
```

**Invalid messages:**

```typescript
client.send.chat.message({ text: "" }); // ❌ Too short, rejected
client.send.chat.message({ text: "x".repeat(501) }); // ❌ Too long, rejected
client.send.chat.message({ text: 123 }); // ❌ Wrong type, TypeScript error
```

Validation errors are logged on the server, and the handler is not called.

## Type Inference

Zocket infers payload types automatically:

```typescript
const router = {
  user: {
    update: zo.message.incoming({
      payload: z.object({
        name: z.string(),
        age: z.number(),
      }),
    }),
  },
};

// Server handler - payload is typed!
const appRouter = zo.router(router, {
  user: {
    update: ({ payload, ctx }) => {
      payload.name; // string
      payload.age; // number
      payload.email; // ❌ TypeScript error: doesn't exist
    },
  },
});

// Client - payload is typed!
client.send.user.update({
  name: "Alice", // ✅
  age: 30, // ✅
  email: "a@b.c", // ❌ TypeScript error: doesn't exist
});
```

## Transformations

Use Zod transforms to modify data:

```typescript
zo.message.incoming({
  payload: z.object({
    text: z.string().trim().toLowerCase(),
    tags: z.string().transform((s) => s.split(",")),
    timestamp: z
      .string()
      .datetime()
      .transform((s) => new Date(s)),
  }),
});
```

Input transforms happen before the handler receives data:

```typescript
// Client sends
client.send.chat.message({
  text: "  HELLO  ",
  tags: "urgent,important",
  timestamp: "2024-01-15T10:00:00Z",
});

// Handler receives
({ payload }) => {
  payload.text; // 'hello' (trimmed and lowercased)
  payload.tags; // ['urgent', 'important'] (split)
  payload.timestamp; // Date object
};
```

## Refinements

Add custom validation logic:

```typescript
zo.message.incoming({
  payload: z
    .object({
      start: z.number(),
      end: z.number(),
    })
    .refine((data) => data.end > data.start, {
      message: "End must be greater than start",
    }),
});
```

## Message Metadata

Messages can include metadata (not part of payload):

```typescript
const router = {
  chat: {
    message: zo.message.incoming({
      payload: z.object({ text: z.string() }),
    }),
  },
};

// Payload: what gets validated and passed to handler
// Everything else is metadata handled by Zocket
```

## Best Practices

### 1. Keep Payloads Focused

```typescript
// ✅ Good: Focused payload
{
  message: zo.message.incoming({
    payload: z.object({
      text: z.string(),
      roomId: z.string(),
    })
  })
}

// ❌ Bad: Kitchen sink payload
{
  message: zo.message.incoming({
    payload: z.object({
      text: z.string(),
      roomId: z.string(),
      userId: z.string(),
      timestamp: z.number(),
      deviceInfo: z.object({...}),
      sessionData: z.object({...}),
    })
  })
}
```

Use context for user data, not payload.

### 2. Use Strict Validation

```typescript
// ✅ Good: Strict validation
payload: z.object({
  age: z.number().int().min(0).max(150),
  email: z.string().email(),
  url: z.string().url(),
});

// ❌ Bad: Too lenient
payload: z.object({
  age: z.number(),
  email: z.string(),
  url: z.string(),
});
```

### 3. Document Complex Schemas

```typescript
const router = {
  game: {
    move: zo.message.incoming({
      payload: z.object({
        // Player ID making the move
        playerId: z.string().uuid(),

        // Move coordinates (0-indexed)
        position: z.object({
          x: z.number().int().min(0).max(7),
          y: z.number().int().min(0).max(7),
        }),

        // Optional piece to promote to (chess)
        promotion: z.enum(["queen", "rook", "bishop", "knight"]).optional(),
      }),
    }),
  },
};
```

### 4. Reuse Schemas

```typescript
const userSchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string().email(),
});

const router = {
  users: {
    create: zo.message.incoming({
      payload: userSchema.omit({ id: true }),
    }),
    update: zo.message.incoming({
      payload: userSchema.partial().required({ id: true }),
    }),
    onCreated: zo.message.outgoing({
      payload: userSchema,
    }),
  },
};
```

## Common Patterns

### Request-Response

```typescript
const router = {
  user: {
    // Request
    getProfile: zo.message.incoming({
      payload: z.object({ userId: z.string() }),
    }),

    // Response
    onProfile: zo.message.outgoing({
      payload: z.object({
        id: z.string(),
        name: z.string(),
        email: z.string(),
      }),
    }),
  },
};
```

### Events

```typescript
const router = {
  game: {
    // Regular update
    onTick: zo.message.outgoing({
      payload: z.object({
        timestamp: z.number(),
        frame: z.number(),
      }),
    }),

    // State change
    onStateChange: zo.message.outgoing({
      payload: z.object({
        from: z.string(),
        to: z.string(),
      }),
    }),
  },
};
```

## Next Steps

- [Implement handlers](/core-concepts/handlers) for incoming messages
- [Use context](/core-concepts/context) to send outgoing messages
- [Add middleware](/core-concepts/middleware) for validation
