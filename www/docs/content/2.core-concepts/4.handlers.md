---
title: Handlers
description: Learn how to implement message handlers in Zocket.
---

# Handlers

Handlers are functions that process incoming messages from clients. They receive validated payloads and have access to the full context object.

## Basic Handler

```typescript
const appRouter = zo.router(router, {
  chat: {
    message: ({ payload, ctx }) => {
      console.log(`Message from ${ctx.user}: ${payload.text}`);
    },
  },
});
```

Every handler receives an object with:

- `payload`: The validated message payload
- `ctx`: The context object

## Handler Structure

Handlers must match your router structure:

```typescript
const router = {
  chat: {
    message: zo.message.incoming({...}),
    typing: zo.message.incoming({...}),
  },
  users: {
    join: zo.message.incoming({...}),
  },
};

const appRouter = zo.router(router, {
  chat: {
    message: ({ payload, ctx }) => {}, // ✅
    typing: ({ payload, ctx }) => {},  // ✅
  },
  users: {
    join: ({ payload, ctx }) => {},    // ✅
  },
});
```

## Accessing Payload

The payload is fully typed based on your schema:

```typescript
const router = {
  user: {
    update: zo.message.incoming({
      payload: z.object({
        name: z.string(),
        age: z.number(),
      }),
    }),
  },
};

const appRouter = zo.router(router, {
  user: {
    update: ({ payload, ctx }) => {
      payload.name; // string - fully typed!
      payload.age; // number - fully typed!
    },
  },
});
```

## Accessing Context

Context contains user data, utilities, and the client ID:

```typescript
({ payload, ctx }) => {
  ctx.clientId; // Unique client identifier
  ctx.user; // User data from onConnect
  ctx.send; // Send messages
  ctx.rooms; // Room operations
};
```

## Sending Messages

Use `ctx.send` to send messages back to clients:

```typescript
({ payload, ctx }) => {
  // Send to the sender
  ctx.send.chat.onMessage({
    user: ctx.user,
    text: payload.text,
  }).to([ctx.clientId]);

  // Send to specific clients
  ctx.send.chat.onMessage({...}).to(['client1', 'client2']);

  // Broadcast to everyone
  ctx.send.chat.onMessage({...}).broadcast();

  // Send to room
  ctx.send.chat.onMessage({...}).toRoom(['general']);
}
```

## Async Handlers

Handlers can be async:

```typescript
const appRouter = zo.router(router, {
  user: {
    create: async ({ payload, ctx }) => {
      const user = await database.users.create(payload);

      ctx.send.user
        .onCreated({
          id: user.id,
          name: user.name,
        })
        .to([ctx.clientId]);
    },
  },
});
```

## Error Handling

Errors in handlers are caught and logged automatically:

```typescript
const appRouter = zo.router(router, {
  user: {
    delete: async ({ payload, ctx }) => {
      try {
        await database.users.delete(payload.id);
        ctx.send.user.onDeleted({ id: payload.id }).to([ctx.clientId]);
      } catch (error) {
        console.error("Delete failed:", error);
        ctx.send.user
          .onError({
            message: "Failed to delete user",
          })
          .to([ctx.clientId]);
      }
    },
  },
});
```

The server won't crash even if a handler throws.

## Room Operations

Manage client rooms in handlers:

```typescript
const appRouter = zo.router(router, {
  chat: {
    joinRoom: ({ payload, ctx }) => {
      ctx.rooms.join(payload.roomId);

      ctx.send.chat
        .onJoined({
          roomId: payload.roomId,
          user: ctx.user,
        })
        .toRoom([payload.roomId]);
    },

    leaveRoom: ({ payload, ctx }) => {
      ctx.send.chat
        .onLeft({
          roomId: payload.roomId,
          user: ctx.user,
        })
        .toRoom([payload.roomId]);

      ctx.rooms.leave(payload.roomId);
    },
  },
});
```

## Handler Organization

For large applications, extract handlers to separate files:

```typescript
// handlers/chat.ts
export const chatHandlers = {
  message: ({ payload, ctx }) => {
    // Handle message
  },
  typing: ({ payload, ctx }) => {
    // Handle typing
  },
};

// handlers/users.ts
export const usersHandlers = {
  join: ({ payload, ctx }) => {
    // Handle join
  },
  leave: ({ payload, ctx }) => {
    // Handle leave
  },
};

// index.ts
import { chatHandlers } from "./handlers/chat";
import { usersHandlers } from "./handlers/users";

const appRouter = zo.router(router, {
  chat: chatHandlers,
  users: usersHandlers,
});
```

## Extracting Business Logic

Keep handlers thin by extracting logic:

```typescript
// services/chat.ts
export async function saveMessage(userId: string, text: string) {
  return await database.messages.create({
    userId,
    text,
    timestamp: Date.now(),
  });
}

export async function broadcastMessage(userId: string, text: string) {
  // Complex broadcasting logic
}

// handlers/chat.ts
import { saveMessage, broadcastMessage } from "../services/chat";

export const chatHandlers = {
  message: async ({ payload, ctx }) => {
    await saveMessage(ctx.clientId, payload.text);
    await broadcastMessage(ctx.clientId, payload.text);

    ctx.send.chat
      .onMessage({
        user: ctx.user,
        text: payload.text,
      })
      .broadcast();
  },
};
```

## Best Practices

### 1. Keep Handlers Focused

```typescript
// ✅ Good: Focused handler
message: async ({ payload, ctx }) => {
  await saveMessage(ctx.clientId, payload.text);
  ctx.send.chat.onMessage({
    user: ctx.user,
    text: payload.text,
  }).broadcast();
}

// ❌ Bad: Does too much
message: async ({ payload, ctx }) => {
  await saveMessage(ctx.clientId, payload.text);
  await updateUserStats(ctx.clientId);
  await checkSpam(payload.text);
  await logActivity(ctx.clientId);
  await sendNotifications(payload.text);
  ctx.send.chat.onMessage({...}).broadcast();
}
```

### 2. Use Descriptive Names

```typescript
// ✅ Good names
updateUserProfile: ({ payload, ctx }) => {...},
deletePost: ({ payload, ctx }) => {...},
markAsRead: ({ payload, ctx }) => {...},

// ❌ Bad names
handle: ({ payload, ctx }) => {...},
process: ({ payload, ctx }) => {...},
doStuff: ({ payload, ctx }) => {...},
```

### 3. Handle Errors Gracefully

```typescript
// ✅ Good: Handles errors
create: async ({ payload, ctx }) => {
  try {
    const result = await database.create(payload);
    ctx.send.user.onCreated(result).to([ctx.clientId]);
  } catch (error) {
    console.error("Create failed:", error);
    ctx.send.user
      .onError({
        message: "Creation failed",
      })
      .to([ctx.clientId]);
  }
};
```

### 4. Validate Business Logic

```typescript
// ✅ Good: Validates business rules
updateProfile: async ({ payload, ctx }) => {
  if (!ctx.isAuthenticated) {
    ctx.send.error.onUnauthorized({}).to([ctx.clientId]);
    return;
  }

  if (payload.age < 13) {
    ctx.send.error
      .onValidation({
        message: "Must be 13 or older",
      })
      .to([ctx.clientId]);
    return;
  }

  await database.update(ctx.userId, payload);
};
```

## Common Patterns

### Request-Response

```typescript
getProfile: async ({ payload, ctx }) => {
  const profile = await database.users.findById(payload.userId);

  ctx.send.user
    .onProfile({
      id: profile.id,
      name: profile.name,
      email: profile.email,
    })
    .to([ctx.clientId]);
};
```

### Broadcasting

```typescript
message: ({ payload, ctx }) => {
  ctx.send.chat
    .onMessage({
      user: ctx.user,
      text: payload.text,
      timestamp: new Date(),
    })
    .broadcast();
};
```

### Room Messaging

```typescript
roomMessage: ({ payload, ctx }) => {
  if (!ctx.rooms.has(payload.roomId)) {
    return; // User not in room
  }

  ctx.send.chat
    .onRoomMessage({
      roomId: payload.roomId,
      user: ctx.user,
      text: payload.text,
    })
    .toRoom([payload.roomId]);
};
```

### State Synchronization

```typescript
updateGameState: ({ payload, ctx }) => {
  const newState = gameEngine.processMove(payload.move);

  ctx.send.game
    .onState({
      state: newState,
      timestamp: Date.now(),
    })
    .toRoom([ctx.gameRoom]);
};
```

## Next Steps

- [Understand context](/core-concepts/context) in detail
- [Add middleware](/core-concepts/middleware) for cross-cutting concerns
- [Learn about rooms](/core-concepts/rooms) for group messaging
