---
title: Context
description: Understanding the context object available in handlers.
---

# Context

The context object (`ctx`) is available in every handler and provides access to user data, messaging utilities, room operations, and client information.

## Context Structure

```typescript
({ payload, ctx }) => {
  ctx.clientId; // string - Unique client identifier
  ctx.send; // Sender - Send messages to clients
  ctx.rooms; // RoomOperations - Manage room membership
  // ... plus any user data from onConnect
};
```

## Client ID

Every connected client has a unique ID:

```typescript
({ payload, ctx }) => {
  console.log(ctx.clientId); // "client_1234567890_abc123"

  // Send message back to sender
  ctx.send.echo.pong({ message: "Hello" }).to([ctx.clientId]);
};
```

Client IDs are generated automatically and persist for the connection lifetime.

## User Context

Data returned from `onConnect` becomes part of the context:

```typescript
const zo = zocket.create({
  headers: z.object({
    token: z.string(),
  }),
  onConnect: async (headers, clientId) => {
    const user = await validateToken(headers.token);

    return {
      userId: user.id,
      username: user.name,
      role: user.role,
      isAuthenticated: true,
    };
  },
});
```

Access in handlers:

```typescript
const appRouter = zo.router(router, {
  chat: {
    message: ({ payload, ctx }) => {
      console.log(ctx.userId); // user.id
      console.log(ctx.username); // user.name
      console.log(ctx.role); // user.role
      console.log(ctx.isAuthenticated); // true

      ctx.send.chat
        .onMessage({
          user: ctx.username, // Use context data
          text: payload.text,
        })
        .broadcast();
    },
  },
});
```

## Sending Messages

The `ctx.send` object provides type-safe message sending:

### Send to Specific Clients

```typescript
ctx.send.chat
  .onMessage({
    user: "Alice",
    text: "Hello",
  })
  .to(["client_123", "client_456"]);
```

### Broadcast to All Clients

```typescript
ctx.send.chat
  .onMessage({
    user: "Alice",
    text: "Hello everyone!",
  })
  .broadcast();
```

### Send to Rooms

```typescript
ctx.send.chat
  .onMessage({
    user: "Alice",
    text: "Hello room!",
  })
  .toRoom(["general", "announcements"]);
```

### Fluent API

The send API is fluent and type-safe:

```typescript
ctx.send
   .chat
   .onMessage({ user: 'Alice', text: 'Hi' })
   .to([ctx.clientId]);

// Full autocomplete at every step!
ctx.send.    // Shows: chat, users, game, etc.
ctx.send.chat.  // Shows: onMessage, onTyping, etc.
ctx.send.chat.onMessage({...}) // Shows: to, toRoom, broadcast
```

## Room Operations

Manage client room membership with `ctx.rooms`:

### Join a Room

```typescript
ctx.rooms.join("general");
ctx.rooms.join("lobby");
```

### Leave a Room

```typescript
ctx.rooms.leave("general");
```

### Check Room Membership

```typescript
if (ctx.rooms.has("general")) {
  console.log("User is in general room");
}
```

### Get Current Rooms

```typescript
const rooms = ctx.rooms.current; // ReadonlySet<string>
console.log([...rooms]); // ['general', 'lobby']
```

### Broadcast to a Room

```typescript
ctx.rooms.broadcast("general", "chat.onMessage", {
  user: "System",
  text: "Welcome!",
});
```

Or use the fluent API:

```typescript
ctx.send.chat
  .onMessage({
    user: "System",
    text: "Welcome!",
  })
  .toRoom(["general"]);
```

## Type-Safe Context

TypeScript infers the exact context type:

```typescript
const zo = zocket.create({
  headers: z.object({ token: z.string() }),
  onConnect: async (headers) => {
    return {
      userId: "user123",
      role: "admin" as const,
    };
  },
});

// In handlers, ctx is fully typed
const appRouter = zo.router(router, {
  admin: {
    action: ({ payload, ctx }) => {
      ctx.userId; // string
      ctx.role; // 'admin'
      ctx.send; // Sender<AppRouter>
      ctx.rooms; // RoomOperations
    },
  },
});
```

## Middleware Context

Middleware can add to the context:

```typescript
const authenticated = zo.message.use(({ ctx }) => {
  if (!ctx.isAuthenticated) {
    throw new Error('Unauthorized');
  }
  return {
    verified: true,
    timestamp: Date.now(),
  };
});

const router = {
  admin: {
    action: authenticated.incoming({
      payload: z.object({...}),
    }),
  },
};

const appRouter = zo.router(router, {
  admin: {
    action: ({ payload, ctx }) => {
      ctx.verified;  // true (from middleware)
      ctx.timestamp; // number (from middleware)
      ctx.userId;    // string (from onConnect)
    },
  },
});
```

## Context at Disconnect

The `onDisconnect` hook receives a modified context:

```typescript
const zo = zocket.create({
  headers: z.object({ token: z.string() }),
  onConnect: async (headers) => {
    return { userId: "123", username: "Alice" };
  },
  onDisconnect: async (ctx, clientId) => {
    // ctx has user data but NO send/rooms operations
    console.log(ctx.userId); // ✅ Available
    console.log(ctx.username); // ✅ Available
    console.log(ctx.clientId); // ✅ Available

    // ReadonlySet of rooms the user was in
    const rooms = ctx.rooms; // ReadonlySet<string>
    console.log([...rooms]);

    // ctx.send doesn't exist in onDisconnect
    // ctx.rooms.join doesn't exist in onDisconnect
  },
});
```

## Best Practices

### 1. Keep Context Lean

Only return necessary data from `onConnect`:

```typescript
// ✅ Good: Only essential data
onConnect: async (headers) => {
  const user = await validateToken(headers.token);
  return {
    userId: user.id,
    role: user.role,
  };
};

// ❌ Bad: Too much data
onConnect: async (headers) => {
  const user = await getFullUserProfile(headers.token);
  return {
    ...user, // Entire user object
    settings: user.settings,
    preferences: user.preferences,
    history: user.history,
  };
};
```

Fetch additional data in handlers when needed.

### 2. Use Destructuring

```typescript
// ✅ Good: Clear what's used
const appRouter = zo.router(router, {
  chat: {
    message: ({ payload, ctx }) => {
      const { username, userId } = ctx;
      // Use username and userId
    },
  },
});
```

### 3. Check Permissions in Context

```typescript
const appRouter = zo.router(router, {
  admin: {
    deleteUser: ({ payload, ctx }) => {
      if (ctx.role !== "admin") {
        ctx.send.error.onUnauthorized({}).to([ctx.clientId]);
        return;
      }

      // Proceed with deletion
    },
  },
});
```

### 4. Use Middleware for Common Context Logic

```typescript
const requireAdmin = zo.message.use(({ ctx }) => {
  if (ctx.role !== 'admin') {
    throw new Error('Requires admin role');
  }
  return { isAdmin: true };
});

const router = {
  admin: {
    deleteUser: requireAdmin.incoming({...}),
    banUser: requireAdmin.incoming({...}),
  },
};
```

## Common Patterns

### Echo Pattern

```typescript
getProfile: async ({ payload, ctx }) => {
  const profile = await database.getProfile(payload.userId);
  ctx.send.user.onProfile(profile).to([ctx.clientId]);
};
```

### Broadcast Pattern

```typescript
announcement: ({ payload, ctx }) => {
  ctx.send.system
    .onAnnouncement({
      message: payload.message,
      from: ctx.username,
    })
    .broadcast();
};
```

### Room Pattern

```typescript
roomMessage: ({ payload, ctx }) => {
  if (!ctx.rooms.has(payload.roomId)) {
    return; // Not in room
  }

  ctx.send.chat
    .onRoomMessage({
      roomId: payload.roomId,
      user: ctx.username,
      text: payload.text,
    })
    .toRoom([payload.roomId]);
};
```

### Conditional Sending

```typescript
notification: ({ payload, ctx }) => {
  if (payload.broadcast) {
    ctx.send.notification.onNotification({...}).broadcast();
  } else if (payload.targets) {
    ctx.send.notification.onNotification({...}).to(payload.targets);
  } else if (payload.rooms) {
    ctx.send.notification.onNotification({...}).toRoom(payload.rooms);
  }
}
```

## Next Steps

- [Learn about middleware](/core-concepts/middleware) to extend context
- [Understand rooms](/core-concepts/rooms) in depth
- [See handler examples](/core-concepts/handlers)
