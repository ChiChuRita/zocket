---
title: Rooms
description: Learn how to use rooms for group messaging and broadcasting.
---

# Rooms

Rooms allow you to group clients and send messages to specific groups. They're perfect for chat rooms, game lobbies, collaborative workspaces, and more.

## What are Rooms?

Rooms are named channels that clients can join and leave. When you send a message to a room, only clients in that room receive it.

```typescript
// Client joins room
ctx.rooms.join("general");

// Send to everyone in the room
ctx.send.chat.message({ text: "Hello!" }).toRoom(["general"]);
```

## Room Operations

### Join a Room

```typescript
({ payload, ctx }) => {
  ctx.rooms.join("lobby");
  ctx.rooms.join("game-room-1");
};
```

A client can be in multiple rooms simultaneously.

### Leave a Room

```typescript
({ payload, ctx }) => {
  ctx.rooms.leave("lobby");
};
```

### Check Membership

```typescript
({ payload, ctx }) => {
  if (ctx.rooms.has("general")) {
    console.log("User is in general room");
  }
};
```

### Get Current Rooms

```typescript
({ payload, ctx }) => {
  const rooms = ctx.rooms.current; // ReadonlySet<string>
  console.log([...rooms]); // ['lobby', 'game-room-1']
};
```

## Sending to Rooms

### Using Fluent API

```typescript
ctx.send.chat
  .message({
    text: "Hello room!",
  })
  .toRoom(["general"]);
```

Multiple rooms at once:

```typescript
ctx.send.notification
  .alert({
    message: "System update",
  })
  .toRoom(["general", "announcements", "moderators"]);
```

### Direct Broadcast

```typescript
ctx.rooms.broadcast("general", "chat.message", {
  text: "Hello!",
});
```

## Complete Room Example

```typescript
const zo = zocket.create({
  headers: z.object({
    username: z.string(),
  }),
  onConnect: (headers) => ({
    username: headers.username,
  }),
  onDisconnect: (ctx) => {
    console.log(`${ctx.username} left rooms:`, [...ctx.rooms]);
  },
});

const router = {
  rooms: {
    join: zo.message.incoming({
      payload: z.object({ roomId: z.string() }),
    }),
    leave: zo.message.incoming({
      payload: z.object({ roomId: z.string() }),
    }),
    message: zo.message.incoming({
      payload: z.object({
        roomId: z.string(),
        text: z.string(),
      }),
    }),
    onJoin: zo.message.outgoing({
      payload: z.object({
        roomId: z.string(),
        username: z.string(),
      }),
    }),
    onLeave: zo.message.outgoing({
      payload: z.object({
        roomId: z.string(),
        username: z.string(),
      }),
    }),
    onMessage: zo.message.outgoing({
      payload: z.object({
        roomId: z.string(),
        username: z.string(),
        text: z.string(),
        timestamp: z.date(),
      }),
    }),
  },
};

const appRouter = zo.router(router, {
  rooms: {
    join: ({ payload, ctx }) => {
      ctx.rooms.join(payload.roomId);

      ctx.send.rooms
        .onJoin({
          roomId: payload.roomId,
          username: ctx.username,
        })
        .toRoom([payload.roomId]);
    },

    leave: ({ payload, ctx }) => {
      ctx.send.rooms
        .onLeave({
          roomId: payload.roomId,
          username: ctx.username,
        })
        .toRoom([payload.roomId]);

      ctx.rooms.leave(payload.roomId);
    },

    message: ({ payload, ctx }) => {
      if (!ctx.rooms.has(payload.roomId)) {
        console.log(`${ctx.username} not in room ${payload.roomId}`);
        return;
      }

      ctx.send.rooms
        .onMessage({
          roomId: payload.roomId,
          username: ctx.username,
          text: payload.text,
          timestamp: new Date(),
        })
        .toRoom([payload.roomId]);
    },
  },
});
```

## Room Patterns

### Chat Room

```typescript
joinRoom: ({ payload, ctx }) => {
  ctx.rooms.join(payload.roomId);

  // Notify others
  ctx.send.chat.onUserJoined({
    roomId: payload.roomId,
    username: ctx.username,
  }).toRoom([payload.roomId]);
},

sendMessage: ({ payload, ctx }) => {
  if (!ctx.rooms.has(payload.roomId)) {
    return; // Not in room
  }

  ctx.send.chat.onMessage({
    roomId: payload.roomId,
    username: ctx.username,
    text: payload.text,
  }).toRoom([payload.roomId]);
}
```

### Game Lobby

```typescript
const lobbies = new Map<string, Set<string>>();

joinLobby: ({ payload, ctx }) => {
  const lobby = lobbies.get(payload.lobbyId) || new Set();
  lobby.add(ctx.clientId);
  lobbies.set(payload.lobbyId, lobby);

  ctx.rooms.join(payload.lobbyId);

  ctx.send.game
    .onLobbyUpdate({
      lobbyId: payload.lobbyId,
      players: [...lobby],
      count: lobby.size,
    })
    .toRoom([payload.lobbyId]);
};
```

### Presence System

```typescript
const roomPresence = new Map<string, Set<string>>();

joinRoom: ({ payload, ctx }) => {
  ctx.rooms.join(payload.roomId);

  const users = roomPresence.get(payload.roomId) || new Set();
  users.add(ctx.username);
  roomPresence.set(payload.roomId, users);

  // Broadcast updated presence
  ctx.send.presence.onUpdate({
    roomId: payload.roomId,
    users: [...users],
  }).toRoom([payload.roomId]);
},

onDisconnect: (ctx) => {
  ctx.rooms.forEach(roomId => {
    const users = roomPresence.get(roomId);
    if (users) {
      users.delete(ctx.username);

      // Can't send from onDisconnect, store for cleanup
      console.log(`Remove ${ctx.username} from ${roomId}`);
    }
  });
}
```

### Broadcast to All Except Sender

```typescript
message: ({ payload, ctx }) => {
  // Get all clients in room
  const roomClients = getRoomClients(payload.roomId);

  // Send to everyone except sender
  const targets = roomClients.filter((id) => id !== ctx.clientId);

  ctx.send.chat
    .onMessage({
      text: payload.text,
      from: ctx.username,
    })
    .to(targets);
};
```

## Room Management

### Dynamic Room Names

```typescript
// User-specific rooms
ctx.rooms.join(`user:${ctx.userId}`);

// Game session rooms
ctx.rooms.join(`game:${gameId}:${sessionId}`);

// Private conversation rooms
const roomId = [userId1, userId2].sort().join(":");
ctx.rooms.join(roomId);
```

### Room Capacity

```typescript
const roomCapacities = new Map<string, number>();

joinRoom: ({ payload, ctx }) => {
  const current = roomCapacities.get(payload.roomId) || 0;

  if (current >= 10) {
    ctx.send.room.onFull({ roomId: payload.roomId }).to([ctx.clientId]);
    return;
  }

  ctx.rooms.join(payload.roomId);
  roomCapacities.set(payload.roomId, current + 1);
};
```

### Room Permissions

```typescript
const roomOwners = new Map<string, string>();

joinRoom: ({ payload, ctx }) => {
  const owner = roomOwners.get(payload.roomId);

  if (owner && !ctx.isAdmin) {
    ctx.send.room.onPrivate({}).to([ctx.clientId]);
    return;
  }

  ctx.rooms.join(payload.roomId);
};
```

## Client-Side Room Usage

```typescript
const client = createZocketClient<AppRouter>("ws://localhost:3000", {
  headers: { username: "Alice" },
});

// Listen for room events
client.on.rooms.onJoin((data) => {
  console.log(`${data.username} joined ${data.roomId}`);
});

client.on.rooms.onMessage((data) => {
  console.log(`[${data.roomId}] ${data.username}: ${data.text}`);
});

// Join room
client.onOpen(() => {
  client.send.rooms.join({ roomId: "general" });
});

// Send message to room
const sendMessage = (text: string) => {
  client.send.rooms.message({
    roomId: "general",
    text,
  });
};
```

## Best Practices

### 1. Validate Room Access

```typescript
message: ({ payload, ctx }) => {
  // Check membership before sending
  if (!ctx.rooms.has(payload.roomId)) {
    console.log(`User ${ctx.username} not in room ${payload.roomId}`);
    return;
  }

  // Send message
  ctx.send.room.onMessage({...}).toRoom([payload.roomId]);
}
```

### 2. Clean Up on Disconnect

Rooms are automatically cleaned up when clients disconnect, but you may want custom logic:

```typescript
const zo = zocket.create({
  headers: z.object({ username: z.string() }),
  onConnect: (headers) => ({ username: headers.username }),
  onDisconnect: async (ctx) => {
    // Custom cleanup
    for (const roomId of ctx.rooms) {
      await database.logRoomLeave(roomId, ctx.username);
    }
  },
});
```

### 3. Use Descriptive Room Names

```typescript
// ✅ Good: Clear naming
ctx.rooms.join("chat:general");
ctx.rooms.join("game:lobby:1");
ctx.rooms.join("private:alice:bob");

// ❌ Bad: Unclear naming
ctx.rooms.join("r1");
ctx.rooms.join("room");
ctx.rooms.join("channel");
```

### 4. Notify on Join/Leave

```typescript
join: ({ payload, ctx }) => {
  ctx.rooms.join(payload.roomId);

  // Notify others
  ctx.send.room
    .onJoin({
      roomId: payload.roomId,
      user: ctx.username,
    })
    .toRoom([payload.roomId]);
};
```

## Performance Considerations

- Room operations are O(1) - very fast
- Broadcasting to rooms is efficient (single publish)
- Clients can be in hundreds of rooms without issues
- Room names are just strings (no memory overhead)

## Next Steps

- [See room examples](/examples/chat-rooms)
- [Learn about context](/core-concepts/context)
- [Build a multiplayer game](/examples/game)
