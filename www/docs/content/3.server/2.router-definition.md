---
title: Router Definition
description: Define your router and implement handlers.
---

# Router Definition

After creating a Zocket instance, define your router with message types and implement handlers.

## Defining the Router

```typescript
const router = {
  chat: {
    message: zo.message.incoming({
      payload: z.object({ text: z.string() }),
    }),
    onMessage: zo.message.outgoing({
      payload: z.object({ user: z.string(), text: z.string() }),
    }),
  },
};
```

## Implementing Handlers

```typescript
const appRouter = zo.router(router, {
  chat: {
    message: ({ payload, ctx }) => {
      ctx.send.chat
        .onMessage({
          user: ctx.username,
          text: payload.text,
        })
        .broadcast();
    },
  },
});
```

## Complete Example

```typescript
import { z } from "zod";
import { zocket } from "@zocket/core";

const zo = zocket.create({
  headers: z.object({
    username: z.string(),
  }),
  onConnect: (headers) => ({
    username: headers.username,
  }),
});

const router = {
  chat: {
    message: zo.message.incoming({
      payload: z.object({
        text: z.string().min(1).max(500),
      }),
    }),
    typing: zo.message.incoming({
      payload: z.object({
        isTyping: z.boolean(),
      }),
    }),
    onMessage: zo.message.outgoing({
      payload: z.object({
        user: z.string(),
        text: z.string(),
        timestamp: z.date(),
      }),
    }),
    onTyping: zo.message.outgoing({
      payload: z.object({
        user: z.string(),
        isTyping: z.boolean(),
      }),
    }),
  },
};

export type ChatRouter = typeof router;

const appRouter = zo.router(router, {
  chat: {
    message: ({ payload, ctx }) => {
      ctx.send.chat
        .onMessage({
          user: ctx.username,
          text: payload.text,
          timestamp: new Date(),
        })
        .broadcast();
    },
    typing: ({ payload, ctx }) => {
      ctx.send.chat
        .onTyping({
          user: ctx.username,
          isTyping: payload.isTyping,
        })
        .broadcast();
    },
  },
});

export default appRouter;
```

## Router Structure

The router object must match the handler structure:

```typescript
// Router defines messages
const router = {
  users: {
    create: zo.message.incoming({...}),
    onCreated: zo.message.outgoing({...}),
  },
};

// Handlers implement incoming messages
const appRouter = zo.router(router, {
  users: {
    create: ({ payload, ctx }) => {
      // Handle create
    },
    // Note: onCreated doesn't need a handler (it's outgoing)
  },
});
```

## Organizing Large Routers

Split into modules for large applications:

```typescript
// routes/chat.ts
export const chatRouter = {
  message: zo.message.incoming({...}),
  onMessage: zo.message.outgoing({...}),
};

// routes/users.ts
export const usersRouter = {
  join: zo.message.incoming({...}),
  onJoin: zo.message.outgoing({...}),
};

// router.ts
import { chatRouter } from './routes/chat';
import { usersRouter } from './routes/users';

export const router = {
  chat: chatRouter,
  users: usersRouter,
};

// handlers/chat.ts
export const chatHandlers = {
  message: ({ payload, ctx }) => {...},
};

// handlers/users.ts
export const usersHandlers = {
  join: ({ payload, ctx }) => {...},
};

// index.ts
import { router } from './router';
import { chatHandlers } from './handlers/chat';
import { usersHandlers } from './handlers/users';

const appRouter = zo.router(router, {
  chat: chatHandlers,
  users: usersHandlers,
});
```

## Type Export

Always export your router type for client use:

```typescript
const router = {
  // ... your routes
};

export type AppRouter = typeof router;

const appRouter = zo.router(router, {
  // ... your handlers
});

export default appRouter;
```

## Next Steps

- [Configure adapters](/server/adapters)
- [Learn about lifecycle hooks](/server/lifecycle)
- [Master sending messages](/server/sending-messages)
