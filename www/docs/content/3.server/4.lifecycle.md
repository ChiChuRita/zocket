---
title: Lifecycle
description: Understanding connection lifecycle hooks in Zocket.
---

# Connection Lifecycle

Zocket provides hooks to handle the complete lifecycle of client connections.

## Lifecycle Flow

```
1. Client connects
   ↓
2. Headers validated
   ↓
3. onConnect() called
   ↓
4. User context created
   ↓
5. Client can send/receive messages
   ↓
6. Client disconnects
   ↓
7. onDisconnect() called
```

## onConnect Hook

Called when a client successfully connects and passes header validation:

```typescript
const zo = zocket.create({
  headers: z.object({
    token: z.string(),
  }),
  onConnect: async (headers, clientId) => {
    console.log(`✅ Client ${clientId} connecting...`);

    // Validate token
    const user = await validateToken(headers.token);

    // Create user context
    return {
      userId: user.id,
      username: user.name,
      role: user.role,
    };
  },
});
```

**Parameters:**

- `headers`: Validated headers object
- `clientId`: Unique client identifier

**Returns:** Object that becomes `ctx` in handlers

## onDisconnect Hook

Called when a client disconnects (gracefully or not):

```typescript
const zo = zocket.create({
  headers: z.object({ user: z.string() }),
  onConnect: (headers) => ({ user: headers.user }),
  onDisconnect: async (ctx, clientId) => {
    console.log(`❌ ${ctx.user} disconnected (${clientId})`);
    console.log(`   Was in rooms:`, [...ctx.rooms]);

    // Cleanup
    await database.updateLastSeen(ctx.user);
  },
});
```

**Parameters:**

- `ctx`: User context (without `send`/`rooms` operations)
- `clientId`: Unique client identifier

## Complete Example

```typescript
import { z } from "zod";
import { zocket } from "@zocket/core";

const connections = new Map();

const zo = zocket.create({
  headers: z.object({
    authorization: z.string(),
    "user-agent": z.string().optional(),
  }),

  onConnect: async (headers, clientId) => {
    const startTime = Date.now();

    try {
      // Validate authorization
      const user = await validateAuth(headers.authorization);

      if (user.banned) {
        throw new Error("User is banned");
      }

      // Log connection
      console.log(`✅ ${user.name} connected`);
      console.log(`   Client ID: ${clientId}`);
      console.log(`   User Agent: ${headers["user-agent"] || "Unknown"}`);

      // Track connection
      connections.set(clientId, {
        userId: user.id,
        connectedAt: startTime,
      });

      // Update database
      await database.users.updateLastSeen(user.id);
      await database.connections.create({
        clientId,
        userId: user.id,
        connectedAt: new Date(),
      });

      // Return context
      return {
        userId: user.id,
        username: user.name,
        email: user.email,
        role: user.role,
        connectedAt: startTime,
      };
    } catch (error) {
      console.error(`❌ Connection failed: ${error.message}`);
      throw error; // Reject connection
    }
  },

  onDisconnect: async (ctx, clientId) => {
    const connection = connections.get(clientId);
    const duration = Date.now() - (connection?.connectedAt || 0);

    // Log disconnection
    console.log(`❌ ${ctx.username} disconnected`);
    console.log(`   Client ID: ${clientId}`);
    console.log(`   Duration: ${duration}ms`);
    console.log(`   Rooms: ${[...ctx.rooms].join(", ") || "none"}`);

    // Update database
    await database.connections.end(clientId, {
      disconnectedAt: new Date(),
      duration,
    });

    // Cleanup
    connections.delete(clientId);

    // Notify others if in rooms
    for (const room of ctx.rooms) {
      // Can't send from onDisconnect, but you can log or cleanup
      await database.rooms.removeUser(room, ctx.userId);
    }
  },
});
```

## Connection Rejection

Throw an error in `onConnect` to reject the connection:

```typescript
onConnect: async (headers, clientId) => {
  const user = await validateToken(headers.token);

  if (!user) {
    throw new Error("Invalid token");
  }

  if (user.banned) {
    throw new Error("User is banned");
  }

  if (await isRateLimited(user.id)) {
    throw new Error("Too many connections");
  }

  return { userId: user.id };
};
```

## Tracking Active Connections

```typescript
const activeUsers = new Map<string, Set<string>>();

const zo = zocket.create({
  headers: z.object({ token: z.string() }),

  onConnect: async (headers, clientId) => {
    const user = await validateToken(headers.token);

    // Track this connection
    if (!activeUsers.has(user.id)) {
      activeUsers.set(user.id, new Set());
    }
    activeUsers.get(user.id)!.add(clientId);

    console.log(
      `User ${user.name} now has ${
        activeUsers.get(user.id)!.size
      } connection(s)`
    );

    return { userId: user.id, username: user.name };
  },

  onDisconnect: async (ctx, clientId) => {
    const clients = activeUsers.get(ctx.userId);
    if (clients) {
      clients.delete(clientId);

      if (clients.size === 0) {
        activeUsers.delete(ctx.userId);
        console.log(`User ${ctx.username} fully disconnected`);
      } else {
        console.log(
          `User ${ctx.username} still has ${clients.size} connection(s)`
        );
      }
    }
  },
});
```

## Session Management

```typescript
const sessions = new Map();

const zo = zocket.create({
  headers: z.object({ sessionId: z.string() }),

  onConnect: async (headers, clientId) => {
    const session = await database.sessions.get(headers.sessionId);

    if (!session || session.expired) {
      throw new Error("Invalid or expired session");
    }

    sessions.set(clientId, {
      sessionId: headers.sessionId,
      userId: session.userId,
      startTime: Date.now(),
    });

    return {
      userId: session.userId,
      sessionId: headers.sessionId,
    };
  },

  onDisconnect: async (ctx, clientId) => {
    const session = sessions.get(clientId);

    if (session) {
      const duration = Date.now() - session.startTime;

      await database.sessions.updateActivity(session.sessionId, {
        lastActivity: new Date(),
        totalDuration: duration,
      });

      sessions.delete(clientId);
    }
  },
});
```

## Best Practices

### 1. Keep onConnect Fast

```typescript
// ✅ Good: Fast validation
onConnect: async (headers, clientId) => {
  const user = await redis.get(`user:${headers.token}`);
  return { userId: user.id };
};

// ❌ Bad: Slow operations
onConnect: async (headers, clientId) => {
  const user = await validateToken(headers.token);
  await loadUserPreferences(user.id);
  await loadUserHistory(user.id);
  await loadUserFriends(user.id);
  return {
    /* lots of data */
  };
};
```

### 2. Handle Errors Gracefully

```typescript
onConnect: async (headers, clientId) => {
  try {
    const user = await validateToken(headers.token);
    return { userId: user.id };
  } catch (error) {
    console.error(`Auth failed for ${clientId}:`, error);
    throw new Error("Authentication failed");
  }
};
```

### 3. Clean Up in onDisconnect

```typescript
onDisconnect: async (ctx, clientId) => {
  // Update database
  await database.updateLastSeen(ctx.userId);

  // Clean up in-memory data
  activeConnections.delete(clientId);
  userSessions.delete(ctx.userId);

  // Log for analytics
  await analytics.logDisconnect(ctx.userId);
};
```

### 4. Log Important Events

```typescript
onConnect: (headers, clientId) => {
  console.log(`✅ ${headers.user} connected (${clientId})`);
  return { user: headers.user };
},

onDisconnect: (ctx, clientId) => {
  console.log(`❌ ${ctx.user} disconnected (${clientId})`);
}
```

## Next Steps

- [Learn about sending messages](/server/sending-messages)
- [Understand context](/core-concepts/context)
- [Implement authentication](/advanced/authentication)
