---
title: Sending Messages
description: Learn how to send messages from the server to clients.
---

# Sending Messages

The server can send messages to clients using the `ctx.send` API, which provides a type-safe fluent interface.

## Basic Sending

```typescript
const appRouter = zo.router(router, {
  chat: {
    message: ({ payload, ctx }) => {
      ctx.send.chat
        .onMessage({
          user: ctx.username,
          text: payload.text,
        })
        .broadcast();
    },
  },
});
```

## Send Targets

### To Specific Clients

Send to one or more specific clients:

```typescript
// Send to one client
ctx.send.chat.onMessage({ text: "Hello!" }).to([ctx.clientId]);

// Send to multiple clients
ctx.send.chat
  .onMessage({ text: "Hello!" })
  .to(["client1", "client2", "client3"]);
```

### Broadcast to All

Send to all connected clients:

```typescript
ctx.send.notification
  .alert({
    message: "System maintenance in 5 minutes",
    type: "warning",
  })
  .broadcast();
```

### Send to Rooms

Send to all clients in specific rooms:

```typescript
// Send to one room
ctx.send.chat.onMessage({ text: "Hello room!" }).toRoom(["general"]);

// Send to multiple rooms
ctx.send.announcement
  .onNews({ text: "Big news!" })
  .toRoom(["general", "announcements"]);
```

## Fluent API

The send API is fully type-safe and chainable:

```typescript
ctx.send.chat // Start sending // Navigate to route
  .onMessage({
    // Select message and provide payload
    user: "Alice",
    text: "Hi",
  })
  .broadcast(); // Choose delivery method
```

TypeScript provides full autocomplete at every step!

## Examples

### Echo Pattern

Send response back to sender:

```typescript
getProfile: async ({ payload, ctx }) => {
  const profile = await database.getProfile(payload.userId);

  ctx.send.user
    .onProfile({
      id: profile.id,
      name: profile.name,
      email: profile.email,
    })
    .to([ctx.clientId]);
};
```

### Broadcast Pattern

Send to everyone:

```typescript
announcement: ({ payload, ctx }) => {
  ctx.send.system
    .onAnnouncement({
      message: payload.message,
      from: ctx.username,
      timestamp: new Date(),
    })
    .broadcast();
};
```

### Room Pattern

Send to room members:

```typescript
roomMessage: ({ payload, ctx }) => {
  if (!ctx.rooms.has(payload.roomId)) {
    return; // Not in room
  }

  ctx.send.chat
    .onRoomMessage({
      roomId: payload.roomId,
      user: ctx.username,
      text: payload.text,
      timestamp: new Date(),
    })
    .toRoom([payload.roomId]);
};
```

### Conditional Sending

Send to different targets based on logic:

```typescript
notification: ({ payload, ctx }) => {
  const message = {
    type: payload.type,
    message: payload.message,
    timestamp: new Date(),
  };

  if (payload.broadcast) {
    ctx.send.notification.onReceive(message).broadcast();
  } else if (payload.targets) {
    ctx.send.notification.onReceive(message).to(payload.targets);
  } else if (payload.rooms) {
    ctx.send.notification.onReceive(message).toRoom(payload.rooms);
  } else {
    ctx.send.notification.onReceive(message).to([ctx.clientId]);
  }
};
```

### Send to All Except Sender

```typescript
message: ({ payload, ctx }) => {
  // Get all room members
  const members = getRoomMembers(payload.roomId);

  // Filter out sender
  const others = members.filter((id) => id !== ctx.clientId);

  ctx.send.chat
    .onMessage({
      user: ctx.username,
      text: payload.text,
    })
    .to(others);
};
```

## Advanced Patterns

### Rate-Limited Sending

```typescript
const lastSend = new Map<string, number>();

message: ({ payload, ctx }) => {
  const now = Date.now();
  const last = lastSend.get(ctx.clientId) || 0;

  if (now - last < 1000) {
    ctx.send.error
      .onRateLimit({
        message: "Sending too fast",
        retryAfter: 1000 - (now - last),
      })
      .to([ctx.clientId]);
    return;
  }

  lastSend.set(ctx.clientId, now);

  ctx.send.chat
    .onMessage({
      user: ctx.username,
      text: payload.text,
    })
    .broadcast();
};
```

### Batched Sending

```typescript
const messageQueue = new Map<string, any[]>();

queueMessage: ({ payload, ctx }) => {
  const queue = messageQueue.get(payload.roomId) || [];
  queue.push({
    user: ctx.username,
    text: payload.text,
    timestamp: new Date(),
  });
  messageQueue.set(payload.roomId, queue);
};

// Flush every second
setInterval(() => {
  messageQueue.forEach((messages, roomId) => {
    if (messages.length > 0) {
      ctx.send.chat
        .onBatch({
          roomId,
          messages,
        })
        .toRoom([roomId]);

      messageQueue.set(roomId, []);
    }
  });
}, 1000);
```

### Targeted Notifications

```typescript
notifyAdmins: ({ payload, ctx }) => {
  const adminClients = getAdminClientIds();

  ctx.send.admin
    .onAlert({
      from: ctx.username,
      message: payload.message,
      severity: "high",
    })
    .to(adminClients);
};
```

## Type Safety

All payloads are validated and type-checked:

```typescript
// Router defines schema
const router = {
  chat: {
    onMessage: zo.message.outgoing({
      payload: z.object({
        user: z.string(),
        text: z.string(),
        priority: z.number(),
      }),
    }),
  },
};

// Sending is type-safe
ctx.send.chat
  .onMessage({
    user: "Alice",
    text: "Hello",
    priority: 1,
  })
  .broadcast(); // ✅ Correct

ctx.send.chat
  .onMessage({
    user: "Alice",
    text: "Hello",
    priority: "high", // ❌ Type error: should be number
  })
  .broadcast();
```

## Performance Tips

### 1. Prefer Room Broadcasting

```typescript
// ✅ Good: Single broadcast to room
ctx.send.chat.onMessage({ text: "Hi" }).toRoom(["general"]);

// ❌ Bad: Individual sends to many clients
const clients = getRoomClients("general");
clients.forEach((id) => {
  ctx.send.chat.onMessage({ text: "Hi" }).to([id]);
});
```

### 2. Batch Updates

Instead of sending every small update:

```typescript
// ✅ Good: Batch updates
const updates = [];
// ... collect updates
ctx.send.game.onStateBatch({ updates }).toRoom(["game"]);

// ❌ Bad: Send each update
updates.forEach((update) => {
  ctx.send.game.onStateUpdate(update).toRoom(["game"]);
});
```

### 3. Avoid Over-Broadcasting

```typescript
// ✅ Good: Targeted sending
if (payload.roomId) {
  ctx.send.chat.onMessage({...}).toRoom([payload.roomId]);
} else {
  ctx.send.chat.onMessage({...}).to([ctx.clientId]);
}

// ❌ Bad: Always broadcasting
ctx.send.chat.onMessage({...}).broadcast();
```

## Next Steps

- [Learn about rooms](/core-concepts/rooms)
- [Understand context](/core-concepts/context)
- [See complete examples](/examples/ping-pong)
