---
title: useEvent
description: Learn how to use the useEvent hook for type-safe event listening.
---

# useEvent Hook

The `useEvent` hook provides a type-safe way to listen to WebSocket events with automatic cleanup.

## Basic Usage

```tsx
import { useZocket } from "@zocket/react";
import type { AppRouter } from "./server";

function Chat() {
  const { client, useEvent } = useZocket<AppRouter>();
  const [messages, setMessages] = useState([]);

  useEvent(client.on.chat.onMessage, (data) => {
    setMessages((prev) => [...prev, data]);
  });

  return (
    <div>
      {messages.map((msg) => (
        <div key={msg.id}>{msg.text}</div>
      ))}
    </div>
  );
}
```

## Parameters

### subscribeFn

The subscription function from `client.on`:

```tsx
useEvent(client.on.chat.onMessage, handler);
useEvent(client.on.users.onJoin, handler);
useEvent(client.on.notification.onReceive, handler);
```

### handler

The callback function that receives the event data:

```tsx
useEvent(client.on.chat.onMessage, (data) => {
  // data is fully typed!
  console.log(data.user, data.text);
});
```

## Type Safety

The handler is fully typed based on your router:

```tsx
// Server defines
const router = {
  chat: {
    onMessage: zo.message.outgoing({
      payload: z.object({
        user: z.string(),
        text: z.string(),
        timestamp: z.date(),
      }),
    }),
  },
};

// Client has full type inference
useEvent(client.on.chat.onMessage, (data) => {
  data.user; // string
  data.text; // string
  data.timestamp; // Date

  data.typo; // ❌ Type error: doesn't exist
});
```

## Automatic Cleanup

The hook automatically unsubscribes when the component unmounts:

```tsx
function Chat() {
  useEvent(client.on.chat.onMessage, (data) => {
    console.log(data);
  });

  // When component unmounts, listener is removed automatically
}
```

## Multiple Events

Subscribe to multiple events:

```tsx
function Chat() {
  const { client, useEvent } = useZocket<AppRouter>();
  const [messages, setMessages] = useState([]);
  const [typing, setTyping] = useState([]);

  useEvent(client.on.chat.onMessage, (data) => {
    setMessages((prev) => [...prev, data]);
  });

  useEvent(client.on.chat.onTyping, (data) => {
    if (data.isTyping) {
      setTyping((prev) => [...prev, data.user]);
    } else {
      setTyping((prev) => prev.filter((u) => u !== data.user));
    }
  });

  return (
    <div>
      <Messages messages={messages} />
      <TypingIndicator users={typing} />
    </div>
  );
}
```

## Updating State

### Adding to Array

```tsx
useEvent(client.on.chat.onMessage, (data) => {
  setMessages((prev) => [...prev, data]);
});
```

### Updating Object

```tsx
useEvent(client.on.user.onUpdate, (data) => {
  setUser((prev) => ({ ...prev, ...data }));
});
```

### Conditional Updates

```tsx
useEvent(client.on.notification.onReceive, (data) => {
  if (data.type === "important") {
    setImportantNotifications((prev) => [...prev, data]);
  }
});
```

## Complex Handlers

### With Side Effects

```tsx
useEvent(client.on.chat.onMessage, (data) => {
  setMessages((prev) => [...prev, data]);

  // Side effects
  playNotificationSound();
  saveToLocalStorage(data);
  updateUnreadCount();
});
```

### With Async Operations

```typescript
useEvent(client.on.user.onUpdate, async (data) => {
  setUser(data);

  // Async operations
  await syncToDatabase(data);
  await updateCache(data);
});
```

## Best Practices

### 1. Stable Handler References

Use `useCallback` for handlers with dependencies:

```tsx
const addMessage = useCallback(
  (data) => {
    setMessages((prev) => [...prev, data]);
    notifyUser(userId, data); // Uses external dependency
  },
  [userId]
);

useEvent(client.on.chat.onMessage, addMessage);
```

### 2. Keep Handlers Lightweight

```tsx
// ✅ Good: Quick state update
useEvent(client.on.game.onState, (data) => {
  setGameState(data);
});

// ❌ Bad: Heavy processing
useEvent(client.on.game.onState, (data) => {
  for (let i = 0; i < 1000000; i++) {
    // Heavy calculation
  }
  setGameState(data);
});
```

### 3. Avoid Creating Functions Inline

```tsx
// ✅ Good: Stable reference
const handleMessage = (data) => {
  setMessages((prev) => [...prev, data]);
};
useEvent(client.on.chat.onMessage, handleMessage);

// ❌ Bad: New function every render
useEvent(client.on.chat.onMessage, (data) => {
  setMessages((prev) => [...prev, data]);
});
```

Actually, the second example is fine! The hook handles this internally.

## Complete Example

```tsx
import { useState, useCallback } from "react";
import { useZocket } from "@zocket/react";
import type { AppRouter } from "./server";

function Chat() {
  const { client, useEvent } = useZocket<AppRouter>();
  const [messages, setMessages] = useState([]);
  const [users, setUsers] = useState([]);
  const [typing, setTyping] = useState(new Set());

  // Listen for messages
  useEvent(client.on.chat.onMessage, (data) => {
    setMessages((prev) => [...prev, data]);
    playSound();
  });

  // Listen for users joining
  useEvent(client.on.users.onJoin, (data) => {
    setUsers((prev) => [...prev, data]);
    showNotification(`${data.username} joined`);
  });

  // Listen for users leaving
  useEvent(client.on.users.onLeave, (data) => {
    setUsers((prev) => prev.filter((u) => u.id !== data.userId));
  });

  // Listen for typing indicators
  useEvent(client.on.chat.onTyping, (data) => {
    setTyping((prev) => {
      const next = new Set(prev);
      if (data.isTyping) {
        next.add(data.user);
      } else {
        next.delete(data.user);
      }
      return next;
    });
  });

  return (
    <div>
      <UserList users={users} />
      <MessageList messages={messages} />
      <TypingIndicator users={[...typing]} />
      <MessageInput />
    </div>
  );
}
```

## Next Steps

- [See complete examples](/examples/ping-pong)
- [Learn about the provider](/react/provider)
- [Understand useZocket](/react/use-zocket)
