---
title: Chat Rooms
description: Build a chat application with multiple rooms.
---

# Chat Rooms Example

A complete chat application with multiple rooms, join/leave functionality, and message broadcasting.

## Complete Example

Based on the test file `packages/core/test/rooms.test.ts`, here's a complete chat room implementation:

```typescript
import { z } from "zod";
import { zocket, createBunServer } from "@zocket/core";

const zo = zocket.create({
  headers: z.object({
    "user-name": z.string().default("Anonymous"),
  }),
  onConnect: (headers, clientId) => {
    return { "user-name": headers["user-name"] };
  },
  onDisconnect: (ctx, clientId) => {
    const rooms = [...ctx.rooms].join(", ") || "none";
    console.log(
      `âŒ ${ctx["user-name"]} (${clientId}) disconnected from rooms: ${rooms}`
    );
  },
});

const chatRouter = {
  rooms: {
    join: zo.message.incoming({
      payload: z.object({ roomId: z.string() }),
    }),
    leave: zo.message.incoming({
      payload: z.object({ roomId: z.string() }),
    }),
    message: zo.message.incoming({
      payload: z.object({
        roomId: z.string(),
        content: z.string(),
      }),
    }),
    onJoin: zo.message.outgoing({
      payload: z.object({
        roomId: z.string(),
        userName: z.string(),
      }),
    }),
    onLeave: zo.message.outgoing({
      payload: z.object({
        roomId: z.string(),
        userName: z.string(),
      }),
    }),
    onMessage: zo.message.outgoing({
      payload: z.object({
        roomId: z.string(),
        userName: z.string(),
        content: z.string(),
        timestamp: z.date(),
      }),
    }),
  },
};

export type ChatRouter = typeof chatRouter;

const appRouter = zo.router(chatRouter, {
  rooms: {
    join: ({ payload, ctx }) => {
      const userName = ctx["user-name"];
      ctx.rooms.join(payload.roomId);

      ctx.send.rooms
        .onJoin({
          roomId: payload.roomId,
          userName,
        })
        .toRoom([payload.roomId]);
    },
    leave: ({ payload, ctx }) => {
      const userName = ctx["user-name"];

      ctx.send.rooms
        .onLeave({
          roomId: payload.roomId,
          userName,
        })
        .toRoom([payload.roomId]);

      ctx.rooms.leave(payload.roomId);
    },
    message: ({ payload, ctx }) => {
      const userName = ctx["user-name"];

      if (!ctx.rooms.has(payload.roomId)) {
        console.log(
          `ðŸš« ${userName} tried to send message to ${payload.roomId} without joining`
        );
        return;
      }

      ctx.send.rooms
        .onMessage({
          roomId: payload.roomId,
          userName,
          content: payload.content,
          timestamp: new Date(),
        })
        .toRoom([payload.roomId]);
    },
  },
});

const handlers = createBunServer(appRouter, zo);

Bun.serve({
  fetch: handlers.fetch,
  websocket: handlers.websocket,
  port: 3000,
});
```

## Client Usage

```typescript
const client = createZocketClient<ChatRouter>("ws://localhost:3000", {
  headers: { "user-name": "Alice" },
});

// Listen for new members
client.on.rooms.onJoin((data) => {
  console.log(`${data.userName} joined ${data.roomId}`);
});

// Listen for messages
client.on.rooms.onMessage((data) => {
  console.log(`[${data.roomId}] ${data.userName}: ${data.content}`);
});

// Join a room
client.onOpen(() => {
  client.send.rooms.join({ roomId: "general" });
});

// Send message
const sendMessage = (roomId: string, content: string) => {
  client.send.rooms.message({ roomId, content });
};
```

## Features Demonstrated

- **Room Management**: Join and leave rooms dynamically
- **Room Validation**: Only members can send messages
- **Broadcasting**: Messages sent to all room members
- **Notifications**: Join/leave events notify other members
- **Disconnect Cleanup**: Rooms are tracked on disconnect
