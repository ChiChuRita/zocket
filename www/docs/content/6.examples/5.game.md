---
title: Real-Time Game
description: Build a real-time multiplayer Pong game with Zocket.
---

# Real-Time Game Example

A complete multiplayer Pong game demonstrating real-time state synchronization, room management, and game logic.

## Overview

This example is based on `packages/examples/demo/server.ts` - a fully functional Pong game with:

- Room-based matchmaking
- Real-time game state broadcasting
- Player input handling
- Collision detection
- Score tracking

## Key Implementation

```typescript
const gameRouter = {
  game: {
    join: zo.message.incoming({
      payload: z.object({
        roomId: z.string(),
        username: z.string(),
      }),
    }),
    move: zo.message.incoming({
      payload: z.object({
        dir: z.enum(["up", "down", "stop"]),
      }),
    }),
    assign: zo.message.outgoing({
      payload: z.object({
        side: z.enum(["left", "right", "spectator"]),
      }),
    }),
    state: zo.message.outgoing({
      payload: z.object({
        ball: z.object({ x: z.number(), y: z.number() }),
        paddles: z.object({ leftY: z.number(), rightY: z.number() }),
        scores: z.object({ left: z.number(), right: z.number() }),
        status: z.enum(["waiting", "playing", "point"]),
        players: z.object({
          left: z.string().optional(),
          right: z.string().optional(),
        }),
      }),
    }),
  },
};

const appRouter = zo.router(gameRouter, {
  game: {
    join: ({ payload, ctx }) => {
      const { roomId, username } = payload;
      if (!rooms.has(roomId)) rooms.set(roomId, createInitialState());

      const state = rooms.get(roomId)!;
      ctx.rooms.join(roomId);

      // Assign player to side
      let side: "left" | "right" | "spectator" = "spectator";
      if (!state.players.left) {
        state.players.left = ctx.clientId;
        side = "left";
      } else if (!state.players.right) {
        state.players.right = ctx.clientId;
        side = "right";
      }

      ctx.send.game.assign({ side }).to([ctx.clientId]);

      // Start game loop if two players
      if (state.players.left && state.players.right) {
        startGameLoop(roomId, publish);
      }
    },
    move: ({ payload, ctx }) => {
      const ref = clientToRoom.get(ctx.clientId);
      if (!ref) return;

      const state = rooms.get(ref.roomId);
      if (!state) return;

      if (ref.side === "left" || ref.side === "right") {
        state.inputs[ref.side] = payload.dir;
      }
    },
  },
});

// Game loop broadcasts state 30 times per second
function startGameLoop(roomId: string, publish: Function) {
  setInterval(() => {
    updateGamePhysics(state);

    const payload = {
      ball: { x: state.ball.x, y: state.ball.y },
      paddles: { leftY: state.paddles.leftY, rightY: state.paddles.rightY },
      scores: { left: state.scores.left, right: state.scores.right },
      status: state.status,
      players: {
        left: state.players.leftName,
        right: state.players.rightName,
      },
    };

    publish(roomId, JSON.stringify({ type: "game.state", payload }));
  }, 1000 / 30); // 30 FPS
}
```

## Client Integration

```typescript
const client = createZocketClient<GameRouter>("ws://localhost:3000");

// Listen for side assignment
client.on.game.assign((data) => {
  console.log(`Assigned to: ${data.side}`);
  playerSide = data.side;
});

// Listen for game state (30 FPS)
client.on.game.state((data) => {
  renderGame(data);
});

// Join game
client.onOpen(() => {
  client.send.game.join({
    roomId: "room1",
    username: "Player1",
  });
});

// Send player input
document.addEventListener("keydown", (e) => {
  if (e.key === "ArrowUp") {
    client.send.game.move({ dir: "up" });
  } else if (e.key === "ArrowDown") {
    client.send.game.move({ dir: "down" });
  }
});

document.addEventListener("keyup", () => {
  client.send.game.move({ dir: "stop" });
});
```

## Features Demonstrated

- **Real-Time State**: 30 FPS game state updates
- **Room Management**: Multiple game rooms
- **Player Assignment**: Auto-assign to left/right/spectator
- **Input Handling**: Process player controls
- **Physics**: Server-side game physics
- **Broadcasting**: Efficient room-based state distribution
- **Cleanup**: Handle player disconnection

## Performance Tips

- Server-authoritative physics prevent cheating
- State updates are batched and sent at fixed intervals
- Only changed state is sent to clients
- Room isolation prevents unnecessary data transfer
