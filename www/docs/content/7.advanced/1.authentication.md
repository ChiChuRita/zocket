---
title: Authentication
description: Implement authentication patterns in Zocket applications.
---

# Authentication

Implement secure authentication for your Zocket applications.

## Header-Based Authentication

Validate authentication in headers:

```typescript
const zo = zocket.create({
  headers: z.object({
    authorization: z.string().regex(/^Bearer .+/),
  }),
  onConnect: async (headers, clientId) => {
    const token = headers.authorization.replace("Bearer ", "");

    try {
      const user = await validateJWT(token);

      return {
        userId: user.id,
        username: user.name,
        role: user.role,
        isAuthenticated: true,
      };
    } catch (error) {
      throw new Error("Invalid token");
    }
  },
});
```

## Middleware-Based Authorization

Protect routes with middleware:

```typescript
const requireAuth = zo.message.use(({ ctx }) => {
  if (!ctx.isAuthenticated) {
    throw new Error("Unauthorized");
  }
  return { verified: true };
});

const requireAdmin = requireAuth.use(({ ctx }) => {
  if (ctx.role !== "admin") {
    throw new Error("Forbidden");
  }
  return { isAdmin: true };
});

const router = {
  user: {
    profile: requireAuth.incoming({
      payload: z.object({ userId: z.string() }),
    }),
  },
  admin: {
    deleteUser: requireAdmin.incoming({
      payload: z.object({ userId: z.string() }),
    }),
  },
};
```

## Role-Based Access Control

```typescript
const requireRole = (allowedRoles: string[]) => {
  return zo.message.use(({ ctx }) => {
    if (!allowedRoles.includes(ctx.role)) {
      throw new Error(`Requires one of: ${allowedRoles.join(', ')}`);
    }
    return { authorizedRole: ctx.role };
  });
};

const router = {
  moderator: {
    banUser: requireRole(['admin', 'moderator']).incoming({...}),
  },
};
```

## Session Management

```typescript
const sessions = new Map<string, SessionData>();

const zo = zocket.create({
  headers: z.object({
    sessionId: z.string(),
  }),
  onConnect: async (headers, clientId) => {
    const session = await database.sessions.get(headers.sessionId);

    if (!session || session.expired) {
      throw new Error("Invalid session");
    }

    sessions.set(clientId, session);

    return {
      userId: session.userId,
      sessionId: headers.sessionId,
    };
  },
  onDisconnect: async (ctx, clientId) => {
    sessions.delete(clientId);
  },
});
```

## Client Setup

```typescript
const token = localStorage.getItem("auth_token");

const client = createZocketClient<AppRouter>("ws://localhost:3000", {
  headers: {
    authorization: `Bearer ${token}`,
  },
});
```

## Token Refresh

```typescript
const refreshAuth = async () => {
  const newToken = await fetch("/api/refresh").then((r) => r.json());
  localStorage.setItem("auth_token", newToken);

  // Reconnect with new token
  client.close();
  createNewClient(newToken);
};
```

## Best Practices

1. **Validate on Connect**: Reject unauthorized connections early
2. **Use HTTPS/WSS**: Encrypt tokens in transit
3. **Short-Lived Tokens**: Refresh tokens regularly
4. **Secure Storage**: Use secure storage for tokens
5. **Middleware for Routes**: Protect individual routes with middleware
