---
title: Validation
description: Advanced validation patterns with Zod and Valibot.
---

# Validation

Zocket supports multiple validation libraries through the StandardSchema specification.

## With Zod

```typescript
import { z } from "zod";

const router = {
  user: {
    create: zo.message.incoming({
      payload: z.object({
        name: z.string().min(1).max(100),
        email: z.string().email(),
        age: z.number().int().min(13).max(120),
        role: z.enum(["user", "admin", "moderator"]),
      }),
    }),
  },
};
```

## With Valibot

```typescript
import * as v from "valibot";

const router = {
  user: {
    create: zo.message.incoming({
      payload: v.object({
        name: v.pipe(v.string(), v.minLength(1), v.maxLength(100)),
        email: v.pipe(v.string(), v.email()),
        age: v.pipe(v.number(), v.integer(), v.minValue(13), v.maxValue(120)),
        role: v.picklist(["user", "admin", "moderator"]),
      }),
    }),
  },
};
```

## Custom Validation

Add custom validation logic:

```typescript
const router = {
  transfer: zo.message.incoming({
    payload: z
      .object({
        amount: z.number().positive(),
        recipient: z.string(),
      })
      .refine((data) => data.amount <= 10000, {
        message: "Transfer limit exceeded",
      }),
  }),
};
```

## Transformations

Transform data after validation:

```typescript
const router = {
  chat: {
    message: zo.message.incoming({
      payload: z.object({
        text: z.string().trim().toLowerCase(),
        tags: z.string().transform((s) => s.split(",")),
        timestamp: z
          .string()
          .datetime()
          .transform((s) => new Date(s)),
      }),
    }),
  },
};
```

## Middleware Validation

Add business logic validation:

```typescript
const validateBalance = zo.message.use(async ({ ctx, payload }) => {
  const balance = await getBalance(ctx.userId);

  if (payload.amount > balance) {
    throw new Error("Insufficient balance");
  }

  return { balance };
});

const router = {
  payment: {
    send: validateBalance.incoming({
      payload: z.object({
        amount: z.number(),
        recipient: z.string(),
      }),
    }),
  },
};
```

## Nested Validation

```typescript
const addressSchema = z.object({
  street: z.string(),
  city: z.string(),
  zip: z.string().regex(/^\d{5}$/),
});

const router = {
  user: {
    update: zo.message.incoming({
      payload: z.object({
        name: z.string(),
        addresses: z.array(addressSchema),
      }),
    }),
  },
};
```

## Validation Errors

Validation errors are logged automatically:

```
SERVER: Invalid payload for message "user.create":
  - name: Required
  - email: Invalid email format
```

The handler is not called when validation fails.
