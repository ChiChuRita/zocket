---
title: Error Handling
description: Best practices for handling errors in Zocket applications.
---

# Error Handling

Implement robust error handling in your Zocket applications.

## Connection Errors

Handle connection failures on client:

```typescript
const client = createZocketClient<AppRouter>("ws://localhost:3000", {
  onOpen: () => {
    console.log("Connected");
    hideErrorMessage();
  },
  onClose: () => {
    console.log("Disconnected");
    showErrorMessage("Connection lost. Reconnecting...");
  },
  maxRetries: 10,
});
```

## Authentication Errors

Reject invalid connections:

```typescript
const zo = zocket.create({
  headers: z.object({ token: z.string() }),
  onConnect: async (headers, clientId) => {
    try {
      const user = await validateToken(headers.token);
      return { userId: user.id };
    } catch (error) {
      console.error("Auth failed:", error);
      throw new Error("Authentication failed");
    }
  },
});
```

## Validation Errors

Validation errors are logged automatically:

```typescript
// Client sends invalid data
client.send.user.create({ age: "invalid" });

// Server logs:
// SERVER: Invalid payload for "user.create": age must be a number
```

## Handler Errors

Catch errors in handlers:

```typescript
const appRouter = zo.router(router, {
  user: {
    create: async ({ payload, ctx }) => {
      try {
        const user = await database.users.create(payload);
        ctx.send.user.onCreated(user).to([ctx.clientId]);
      } catch (error) {
        console.error("Create failed:", error);
        ctx.send.user
          .onError({
            message: "Failed to create user",
          })
          .to([ctx.clientId]);
      }
    },
  },
});
```

## Middleware Errors

Errors in middleware stop execution:

```typescript
const requireAuth = zo.message.use(({ ctx }) => {
  if (!ctx.userId) {
    throw new Error("Unauthorized"); // Handler won't run
  }
  return {};
});
```

## Error Messages

Send error messages to clients:

```typescript
const router = {
  error: {
    onError: zo.message.outgoing({
      payload: z.object({
        code: z.string(),
        message: z.string(),
      }),
    }),
  },
};

// In handler
if (error) {
  ctx.send.error
    .onError({
      code: "VALIDATION_ERROR",
      message: "Invalid input",
    })
    .to([ctx.clientId]);
}
```

## Client-Side Error Handling

```typescript
// Listen for errors
client.on.error.onError((data) => {
  showErrorNotification(data.message);
});

// Handle specific errors
client.on.error.onError((data) => {
  if (data.code === "AUTH_ERROR") {
    redirectToLogin();
  } else {
    showGenericError(data.message);
  }
});
```

## Best Practices

1. **Fail Fast**: Validate early in the pipeline
2. **Log Errors**: Always log errors for debugging
3. **User Feedback**: Send meaningful errors to clients
4. **Graceful Degradation**: Handle errors without crashing
5. **Retry Logic**: Implement retry for transient failures
