---
title: Type Safety
description: Deep dive into Zocket's type system and TypeScript integration.
---

# Type Safety

Zocket provides end-to-end type safety through TypeScript's powerful type inference.

## How It Works

```typescript
// 1. Server defines schema
const router = {
  chat: {
    message: zo.message.incoming({
      payload: z.object({ text: z.string(), priority: z.number() }),
    }),
  },
};

// 2. Type is exported
export type AppRouter = typeof router;

// 3. Client gets full types
const client = createZocketClient<AppRouter>("ws://...");

// 4. TypeScript infers everything
client.send.chat.message({ text: "Hi", priority: 1 }); // ✅
client.send.chat.message({ text: "Hi", priority: "high" }); // ❌ Type error
```

## Type Inference

### Payload Types

```typescript
// Server
const router = {
  user: {
    update: zo.message.incoming({
      payload: z.object({
        name: z.string(),
        age: z.number(),
      }),
    }),
  },
};

// Handler automatically infers payload type
const appRouter = zo.router(router, {
  user: {
    update: ({ payload, ctx }) => {
      payload.name; // string
      payload.age; // number
      payload.email; // ❌ Type error: doesn't exist
    },
  },
});
```

### Context Types

```typescript
const zo = zocket.create({
  headers: z.object({ token: z.string() }),
  onConnect: async (headers) => {
    return {
      userId: "user123",
      role: "admin" as const,
    };
  },
});

// Handlers know the exact context type
({ payload, ctx }) => {
  ctx.userId; // string
  ctx.role; // 'admin'
};
```

### Middleware Types

```typescript
const withTimestamp = zo.message.use(() => ({
  timestamp: Date.now(),
  requestId: crypto.randomUUID(),
}));

// Handler knows about middleware additions
const router = {
  api: {
    call: withTimestamp.incoming({...}),
  },
};

const appRouter = zo.router(router, {
  api: {
    call: ({ ctx }) => {
      ctx.timestamp; // number
      ctx.requestId; // string
    },
  },
});
```

## Type Utilities

### Extracting Types

```typescript
// Get payload type
type ChatMessage = z.infer<typeof router.chat.message.payload>;

// Get handler parameters
type ChatHandler = Parameters<(typeof appRouter)["chat"]["message"]>[0];
```

### Router Types

```typescript
import type { AnyRouter } from "@zocket/core";

// Use in generic functions
function createClient<T extends AnyRouter>(router: T) {
  return createZocketClient<T>("ws://...");
}
```

## Type Safety Benefits

### Compile-Time Errors

```typescript
// ❌ Caught at compile time
client.send.chat.typo({ text: "Hi" });
// Error: Property 'typo' does not exist

// ❌ Caught at compile time
client.send.chat.message({ count: 5 });
// Error: Object literal may only specify known properties
```

### IDE Autocomplete

TypeScript provides full autocomplete:

- Route names
- Payload fields
- Context properties
- Middleware additions

### Refactoring Safety

Change the schema:

```typescript
// Change payload
payload: z.object({
  text: z.string(),
  priority: z.number(), // Added field
});
```

TypeScript shows everywhere that needs updating!

## Best Practices

1. **Enable Strict Mode**: `"strict": true` in tsconfig.json
2. **Export Router Types**: Always export `typeof router`
3. **Avoid `any`**: Never use `any` types
4. **Use Const Assertions**: For literal types
5. **Type Guards**: Use type guards for union types

## Advanced Patterns

### Conditional Types

```typescript
type MessageType<T> = T extends { _direction: "in" } ? "incoming" : "outgoing";
```

### Mapped Types

```typescript
type Routes<T extends AnyRouter> = {
  [K in keyof T]: T[K] extends AnyRouter ? Routes<T[K]> : K;
};
```

## TypeScript Configuration

Recommended tsconfig.json:

```json
{
  "compilerOptions": {
    "strict": true,
    "target": "ES2020",
    "module": "ES2020",
    "moduleResolution": "bundler",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  }
}
```
