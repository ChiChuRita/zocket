---
title: Best Practices
description: Learn best practices for building production-ready Zocket applications.
---

# Best Practices

Follow these best practices to build robust, scalable Zocket applications.

## Project Structure

Organize your code for maintainability:

```
project/
├── server/
│   ├── index.ts          # Server entry
│   ├── router.ts         # Router definitions
│   ├── handlers/         # Handler implementations
│   │   ├── chat.ts
│   │   └── users.ts
│   └── middleware/       # Middleware functions
│       ├── auth.ts
│       └── logging.ts
├── shared/
│   └── types.ts          # Shared types
└── client/
    └── index.ts          # Client setup
```

## Type Safety

1. **Always Export Router Types**

```typescript
const router = {...};
export type AppRouter = typeof router;
```

2. **Use Strict TypeScript**

```json
{
  "compilerOptions": {
    "strict": true
  }
}
```

3. **Avoid `any`**

Never use `any` types - it defeats type safety.

## Security

1. **Validate Headers**

```typescript
headers: z.object({
  authorization: z.string().regex(/^Bearer .+/),
});
```

2. **Use HTTPS/WSS in Production**

```typescript
const url = import.meta.env.PROD ? "wss://api.prod.com" : "ws://localhost:3000";
```

3. **Rate Limiting**

```typescript
const rateLimit = createRateLimiter(10, 60000); // 10 per minute

const withRateLimit = zo.message.use(({ ctx }) => {
  if (!rateLimit.check(ctx.clientId)) {
    throw new Error("Rate limit exceeded");
  }
  return {};
});
```

4. **Input Validation**

Always validate all inputs with strict schemas.

## Performance

1. **Keep Handlers Lightweight**

```typescript
// ✅ Good: Fast handler
message: async ({ payload, ctx }) => {
  ctx.send.chat.onMessage(payload).broadcast();
};

// ❌ Bad: Slow handler
message: async ({ payload, ctx }) => {
  await heavyComputation();
  await multipleDBQueries();
  ctx.send.chat.onMessage(payload).broadcast();
};
```

2. **Use Room Broadcasting**

```typescript
// ✅ Good: Single broadcast
ctx.send.chat.onMessage({...}).toRoom(['general']);

// ❌ Bad: Multiple sends
clients.forEach(id => {
  ctx.send.chat.onMessage({...}).to([id]);
});
```

3. **Batch Updates**

Send batched updates instead of individual messages.

4. **Connection Pooling**

Reuse database connections:

```typescript
const pool = createPool({...});

onConnect: async (headers) => {
  const user = await pool.query('SELECT ...');
  return { userId: user.id };
}
```

## Error Handling

1. **Graceful Degradation**

```typescript
try {
  await riskyOperation();
} catch (error) {
  console.error("Operation failed:", error);
  // Continue with degraded functionality
}
```

2. **User Feedback**

Always send meaningful errors to users:

```typescript
catch (error) {
  ctx.send.error.onError({
    message: 'Failed to process request',
    code: 'PROCESS_ERROR',
  }).to([ctx.clientId]);
}
```

3. **Logging**

Log all important events and errors.

## Scalability

1. **Stateless Handlers**

Keep handlers stateless when possible.

2. **External State Management**

Use Redis or similar for shared state:

```typescript
const gameState = await redis.get(`game:${roomId}`);
```

3. **Load Balancing**

Use sticky sessions for WebSocket load balancing.

4. **Monitoring**

Monitor connection counts, message rates, and errors.

## Testing

1. **Unit Test Handlers**

```typescript
test("chat message handler", async () => {
  const ctx = createMockContext();
  await handlers.chat.message({
    payload: { text: "test" },
    ctx,
  });
  expect(ctx.send.chat.onMessage).toHaveBeenCalled();
});
```

2. **Integration Tests**

Test full client-server communication.

3. **Load Testing**

Test with many concurrent connections.

## Deployment

1. **Environment Variables**

```typescript
const PORT = process.env.PORT || 3000;
const WS_URL = process.env.WS_URL;
```

2. **Health Checks**

Implement health check endpoints.

3. **Graceful Shutdown**

```typescript
process.on("SIGTERM", () => {
  server.stop(false); // Graceful shutdown
});
```

4. **Monitoring**

Use monitoring tools to track:

- Connection count
- Message rate
- Error rate
- Response times

## Documentation

1. **Document Routes**

```typescript
const router = {
  chat: {
    // Sends a message to a chat room
    // Requires: User must be in the room
    message: zo.message.incoming({...}),
  },
};
```

2. **API Documentation**

Generate API docs from your router.

3. **Keep README Updated**

Document setup, configuration, and deployment.
