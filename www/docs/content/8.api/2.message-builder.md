---
title: Message Builder
description: API reference for the MessageBuilder class.
---

# Message Builder

The message builder creates message definitions with validation and middleware.

## Methods

### incoming()

Creates an incoming message (client → server).

```typescript
zo.message.incoming({
  payload: Schema
}): IncomingMessage
```

**Example:**

```typescript
zo.message.incoming({
  payload: z.object({
    text: z.string(),
    priority: z.number(),
  }),
});
```

### outgoing()

Creates an outgoing message (server → client).

```typescript
zo.message.outgoing({
  payload: Schema
}): OutgoingMessage
```

**Example:**

```typescript
zo.message.outgoing({
  payload: z.object({
    user: z.string(),
    text: z.string(),
  }),
});
```

### use()

Adds middleware to the message builder.

```typescript
zo.message.use<TAddedContext>(
  middleware: (args: {
    ctx: TContext;
    payload: unknown;
  }) => TAddedContext | Promise<TAddedContext>
): MessageBuilder<TContext & TAddedContext>
```

**Example:**

```typescript
const authenticated = zo.message.use(({ ctx }) => {
  if (!ctx.userId) {
    throw new Error('Unauthorized');
  }
  return { verified: true };
});

authenticated.incoming({ payload: z.object({...}) })
```

## Chaining

Middleware can be chained:

```typescript
const first = zo.message.use(() => ({ step: 1 }));
const second = first.use(() => ({ step: 2 }));
const third = second.use(() => ({ step: 3 }));

third.incoming({ payload: z.object({...}) })
```

## Type Safety

The builder maintains type information through chaining:

```typescript
const withUser = zo.message.use(() => ({
  user: { id: 'user123', name: 'Alice' }
}));

// Handler knows about ctx.user
const router = {
  api: {
    call: withUser.incoming({...}),
  },
};

const appRouter = zo.router(router, {
  api: {
    call: ({ ctx }) => {
      ctx.user.id;   // string
      ctx.user.name; // string
    },
  },
});
```
